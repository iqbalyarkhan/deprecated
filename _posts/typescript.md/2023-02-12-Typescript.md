---
title: 'React and Typescript'
date: 2023-02-10
tags:
  - react
---

## Intro

Typescript is a strict syntactical superset of JavaScript and adds optional static typing to the language. It is designed for the development of large applications and transpiles to JavaScript.

## Compiler

Let's start at the compiler: programs are files that contain a bunch of text written by you, the programmer. That text is parsed by a special program called a compiler, which trans‐ forms it into an abstract syntax tree (AST), a data structure that ignores things like whitespace, comments, and where you stand on the tabs versus spaces debate. After the TypeScript Compiler generates an AST for your program—but before it emits code—it typechecks your code. The compiler then converts that AST to a lower-level representation called bytecode. You can feed that bytecode into another program called a runtime to evaluate it and get a result. So when you run a program, what you’re really doing is telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code.

Where TypeScript is special is that instead of compiling straight to bytecode, TS compiles to JavaScript code. You then run that JavaScript code like you normally would—in your browser, or with NodeJS.

This typechecking is the magic behind TypeScript. It’s how TypeScript makes sure that your program works as you expect, that there aren’t obvious mistakes.

## The Type System

To explicitly signal to TypeScript what your types are, use annotations. Annotations take the form value: type and tell the typechecker, “Hey! You see this value here? Its type is type.” Let’s look at a few examples (the comments following each line are the actual types inferred by TypeScript):

```tsx
let a: number = 1; // a is a number
let b: string = 'hello'; // b is a string
let c: boolean[] = [true, false]; // c is an array of booleans
```

And if you want TypeScript to infer your types for you, just leave them off and let TypeScript get to work:

```tsx
let a = 1; // a is a number
let b = 'hello'; // b is a string
let c = [true, false]; // c is an array of booleans
```

TypeScript is a gradually typed language. That means that TypeScript works best when it knows the types of everything in your program at compile time, but it doesn’t have to know every type in order to compile your program. Even in an untyped program, TypeScript can infer some types for you and catch some mistakes, but without knowing the types for everything, it will let a lot of mistakes slip through to your users. TypeScript statically analyzes your code for errors, and shows them to you before you run it.

## tsconfig.json

Every TypeScript project should include a file called `tsconfig.json` in its root directory. This tsconfig.json is where TypeScript projects define things like which files should be compiled, which directory to compile them to, and which version of JavaScript to emit.

```ts
{
  "compilerOptions": {
    //Which APIs should TSC assume exist in the environment you’ll be running your code in? This includes things like ES5’sFunction.prototype.bind, ES2015’sObject.assign, and the DOM’s document.querySelector.
    "lib": ["es2015"],
    // Which module system should TSC compile your code to (CommonJS, SystemJS, ES2015, etc.)?
    "module": "commonjs",
    // Which folder should TSC put your generated JavaScript code in?
    "outDir": "dist",
    "sourceMap": true,
    //Be as strict as possible when checking for invalid code. This option enforces that all of your code is properly typed. We’ll be using it for all of the examples in the book, and you should use it for your TypeScript project too.
    "strict": true,
    //Which JavaScript version should TSC compile your code to (ES3, ES5, ES2015, ES2016, etc.)?
    "target": "es2015"
  },
  //# Which folders should TSC look in to find your TypeScript files?
  "include": ["src"]
}
```

## tslint.json

Your project should also have a `tslint.json` file containing your TSLint configuration, codifying whatever stylistic conventions you want for your code (tabs versus spaces, etc.).

The following command will generate a tslint.json file with a default TSLint configuration:

```bash
./node_modules/.bin/tslint --init
```

You can then add overrides to this to conform with your own coding style. For example, my tslint.json looks like this:

```tsx
{
  "defaultSeverity": "error",
  "extends": [
      "tslint:recommended"
  ],
  "rules": {
    "semicolon": false,
    "trailing-comma": false
  }
}
```

## index.ts

Now that you’ve set up your tsconfig.json and tslint.json, create a src folder containing your first TypeScript file:

```bash
mkdir src
touch src/index.ts
```

Your project’s folder structure should now look this:

```text
    chapter-2/
    ├──node_modules/
    ├──src/
    │ └──index.ts
    ├──package.json
    ├──tsconfig.json
    └──tslint.json
```

Pop open src/index.ts in your code editor, and enter the following TypeScript code:

```tsx
console.log('Hello TypeScript!');
```

Then, compile and run your TypeScript code:

```tsx
# Compile your TypeScript with TSC
./node_modules/.bin/tsc
# Run your code with NodeJS
node ./dist/index.js
```

This will print `Hello Typescript` in your terminal! With `ts-node` installed, you can simply do this:

```bash
ts-node index.ts
```

## Types

Officially a type is set of values and the things you can do with them. For example:

• The boolean type is the set of all booleans (there are just two: true and false)
and the operations you can perform on them (like ||, &&, and !).

• The number type is the set of all numbers and the operations you can perform on them (like +, -, \*, /, %, ||, &&, and ?), including the methods you can call on them like .toFixed, .toPrecision, .toString, and so on.

• The string type is the set of all strings and the operations you can perform on them (like +, ||, and &&), including the methods you can call on them like .concat and .toUpperCase.

When you see that something is of type T, not only do you know that it’s a T, but you also know exactly what you can do with that T (and what you can’t). Remember, the whole point is to use the typechecker to stop you from doing invalid things. And the way the typechecker knows what’s valid and what’s not is by looking at the types you’re using and how you’re using them.

You can also define your own type:

```tsx
type Programmer = {
  /**
   * The full name of the Programmer
   */
  name: string;
  /**
   * This Programmer is known for what?
   */
  knownFor: string[];
};

const ada: Programmer = {
  name: 'Ada Lovelace',
  knownFor: ['Mathematics', 'Computing', 'First Programmer'],
};
```

Comments you see above are docstring comments.

Here's what typescript's type hierarchy looks like:

![](type-hierarchy.png)

Say you have a function that takes some value and returns that value multiplied by itself:

```tsx
function squareOf(n) {
  return n * n;
}
// squareOf(2) evaluates to 4
// squareOf('z') evaluates to NaN
```

Clearly, this function will only work for numbers—if you pass anything besides a number to squareOf, the result will be invalid. So what we do is explicitly annotate the parameter’s type:

```tsx
function squareOf(n: number) {
  return n * n;
}
```

We can say the following things about the last code example:

1. squareOf’s parameter n is constrained to number.

2. The type of the value 2 is assignable to (equivalently: compatible with) number.

Without a type annotation, squareOf is unconstrained in its parameter, and you can pass any type of argument to it. Once we constrain it, TypeScript goes to work for us verifying that every place we call our function, we call it with a compatible argument.

### any

any is the Godfather of types. It does anything for a price, but you don’t want to ask any for a favor unless you’re completely out of options. In TypeScript everything needs to have a type at compile time, and any is the default type when you (the pro‐ grammer) and TypeScript (the typechecker) can’t figure out what type something is. It’s a last resort type, and you should avoid it when possible. any is the set of all values, and you can do anything with any. That means that if you have a value of type any you can add to it, multiply by it, call .pizza() on it—anything.

```tsx
let a: any = 666; // any
let b: any = ['danger']; // any
let c = a + b; // any
```

Using any in the above, no errors are thrown! My compiler returned this:

```tsx
666danger
```

### unknown

For the few cases where you have a value whose type you really don’t know ahead of time, don’t use any, and instead reach for unknown. Like any, it represents any value, but TypeScript won’t let you use an unknown type until you refine it by checking what it is. (more on refinement later)

### boolean

```tsx
leta = true;
var b = false;
const c = true;
let d: boolean = true;
let e: true = true;
let f: true = false; // Error TS2322: Type 'false' is not assignable to type 'true'.
```

`e` isn’t just any old boolean—it’s the specific boolean true. By using a value as a type, we essentially limited the possible values for `e` and `f` from all booleans to one specific boolean each. This feature is called **type literals**.

**type literal** : A type that represents a single value and nothing else

### number

number is the set of all numbers: integers, floats, positives, negatives, Infinity, NaN, and so on. Numbers can do, well, numbery things, like addition (+), subtraction (-), modulo (%), and comparison (<).Example:

```tsx
let a = 1234;
var b = Infinity * 0.1;
const c = 5678;
let d = a < b; //bool
let e: number = 100;
let f: 26.218 = 26.218; // 26.218
f = 27; // Type '27' is not assignable to type '26.218'
let g: 26.218 = 10; // Error TS2322: Type '10' is not assignable to type '26.218'.
```

### objects

TypeScript’s object types specify the shapes of objects. If you try this:

```tsx
let a: object = { b: 'x' };
```

you'll get an error saying: `Property 'b' does not exist on type 'object'`. Wait, that’s not very useful! What’s the point of typing something as an object if you can’t do anything with it? `object` is a little narrower than any, but not by much. object doesn’t tell you a lot about the value it describes, just that the value is a JavaScript object (and that it’s not null).

You can do 2 things:

- Leave off the `object`:

```tsx
let a = { b: 'x' };
```

- Explicitly provide type for `b`:

```tsx
let a: { b: string } = {
  b: 'hello!',
};
console.log(a.b);
```

This is called `object literal` syntax. Object literal syntax says, “Here is a thing that has this shape.” The thing might be an object literal, or it might be a class:

```tsx
let a: { firstName: string; lastName: string } = {
  firstName: 'john',
  lastName: 'barrowman',
};
class Person {
  constructor(public firstName: string, public lastName: string) {}
}
a = new Person('matt', 'smith'); // OK
```

`{firstName: string, lastName: string}` describes the shape of an object, and both the object literal and the class instance from the last example satisfy that shape, so TypeScript lets us assign a Person to `a`.

Can you tell TypeScript that something is optional, or that there might be more properties than you planned for? You bet:

```tsx
let a: {
  b: number; // 1
  c?: string; // 2
  [key: number]: boolean; // 3
};
```

`a`:

1. has property `b` that is a number

2. might have a property `c` that is string that is optional. And if `c` exists, it might be undefined

3. might have any number of numeric properties that are booleans. This too is optional

Example:

```tsx
a = { b: 1, c: undefined, 10: true, 20: false, 30: true };
a = { b: 1, c: undefined };
a = { b: 1, c: 'd' };
a = { b: 1, 10: true };
a = { b: 1, 10: true, 20: false };
```

The `[key: T]: U` syntax is called an **index signature**, and this is the way you tell TypeScript that the given object might contain more keys. The way to read it is, “For this object, all keys of type T must have values of type U.” Index signatures let you safely add more keys to an object, in addition to any keys that you explicitly declared. What this means is that for `a`, if you have a number on the left, then it must have a boolean assigned:

```tsx
// not ok:
let a: {
  b: number;
  c?: string;
  2: string; // <-- NO!
  [key: number]: boolean;
};
```

Error for above will be: `Property '2' of type 'string' is not assignable to 'number' index type 'boolean'.ts(2411)`

```tsx
// this is ok:
let a: {
  b: number;
  c?: string;
  2: boolean;
  5: boolean;
  [key: number]: boolean;
};

a = { b: 1, c: undefined, 10: true, 20: false, 2: true, 5: false };
```

There is one rule to keep in mind for index signatures: the index signature key’s type, T, must be assignable to either number or string. [P30]
