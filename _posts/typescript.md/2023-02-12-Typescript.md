---
title: 'Typescript'
date: 2023-02-10
tags:
  - typescript
---

## Intro

Typescript is a strict syntactical superset of JavaScript and adds optional static typing to the language. It is designed for the development of large applications and transpiles to JavaScript.

## Compiler

Let's start at the compiler: programs are files that contain a bunch of text written by you, the programmer. That text is parsed by a special program called a compiler, which trans‐ forms it into an abstract syntax tree (AST), a data structure that ignores things like whitespace, comments, and where you stand on the tabs versus spaces debate. After the TypeScript Compiler generates an AST for your program—but before it emits code—it typechecks your code. The compiler then converts that AST to a lower-level representation called bytecode. You can feed that bytecode into another program called a runtime to evaluate it and get a result. So when you run a program, what you’re really doing is telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code.

Where TypeScript is special is that instead of compiling straight to bytecode, TS compiles to JavaScript code. You then run that JavaScript code like you normally would—in your browser, or with NodeJS.

This typechecking is the magic behind TypeScript. It’s how TypeScript makes sure that your program works as you expect, that there aren’t obvious mistakes.

## The Type System

To explicitly signal to TypeScript what your types are, use annotations. Annotations take the form value: type and tell the typechecker, “Hey! You see this value here? Its type is type.” Let’s look at a few examples (the comments following each line are the actual types inferred by TypeScript):

```tsx
let a: number = 1; // a is a number
let b: string = 'hello'; // b is a string
let c: boolean[] = [true, false]; // c is an array of booleans
```

And if you want TypeScript to infer your types for you, just leave them off and let TypeScript get to work:

```tsx
let a = 1; // a is a number
let b = 'hello'; // b is a string
let c = [true, false]; // c is an array of booleans
```

TypeScript is a gradually typed language. That means that TypeScript works best when it knows the types of everything in your program at compile time, but it doesn’t have to know every type in order to compile your program. Even in an untyped program, TypeScript can infer some types for you and catch some mistakes, but without knowing the types for everything, it will let a lot of mistakes slip through to your users. TypeScript statically analyzes your code for errors, and shows them to you before you run it.

## tsconfig.json

Every TypeScript project should include a file called `tsconfig.json` in its root directory. This tsconfig.json is where TypeScript projects define things like which files should be compiled, which directory to compile them to, and which version of JavaScript to emit.

```ts
{
  "compilerOptions": {
    //Which APIs should TSC assume exist in the environment you’ll be running your code in? This includes things like ES5’sFunction.prototype.bind, ES2015’sObject.assign, and the DOM’s document.querySelector.
    "lib": ["es2015"],
    // Which module system should TSC compile your code to (CommonJS, SystemJS, ES2015, etc.)?
    "module": "commonjs",
    // Which folder should TSC put your generated JavaScript code in?
    "outDir": "dist",
    "sourceMap": true,
    //Be as strict as possible when checking for invalid code. This option enforces that all of your code is properly typed. We’ll be using it for all of the examples in the book, and you should use it for your TypeScript project too.
    "strict": true,
    //Which JavaScript version should TSC compile your code to (ES3, ES5, ES2015, ES2016, etc.)?
    "target": "es2015"
  },
  //# Which folders should TSC look in to find your TypeScript files?
  "include": ["src"]
}
```

## tslint.json

Your project should also have a `tslint.json` file containing your TSLint configuration, codifying whatever stylistic conventions you want for your code (tabs versus spaces, etc.).

The following command will generate a tslint.json file with a default TSLint configuration:

```bash
./node_modules/.bin/tslint --init
```

You can then add overrides to this to conform with your own coding style. For example, my tslint.json looks like this:

```tsx
{
  "defaultSeverity": "error",
  "extends": [
      "tslint:recommended"
  ],
  "rules": {
    "semicolon": false,
    "trailing-comma": false
  }
}
```

## index.ts

Now that you’ve set up your tsconfig.json and tslint.json, create a src folder containing your first TypeScript file:

```bash
mkdir src
touch src/index.ts
```

Your project’s folder structure should now look this:

```text
    chapter-2/
    ├──node_modules/
    ├──src/
    │ └──index.ts
    ├──package.json
    ├──tsconfig.json
    └──tslint.json
```

Pop open src/index.ts in your code editor, and enter the following TypeScript code:

```tsx
console.log('Hello TypeScript!');
```

Then, compile and run your TypeScript code:

```tsx
# Compile your TypeScript with TSC
./node_modules/.bin/tsc
# Run your code with NodeJS
node ./dist/index.js
```

This will print `Hello Typescript` in your terminal! With `ts-node` installed, you can simply do this:

```bash
ts-node index.ts
```

## Types

Officially a type is set of values and the things you can do with them. For example:

• The boolean type is the set of all booleans (there are just two: true and false)
and the operations you can perform on them (like ||, &&, and !).

• The number type is the set of all numbers and the operations you can perform on them (like +, -, \*, /, %, ||, &&, and ?), including the methods you can call on them like .toFixed, .toPrecision, .toString, and so on.

• The string type is the set of all strings and the operations you can perform on them (like +, ||, and &&), including the methods you can call on them like .concat and .toUpperCase.

When you see that something is of type T, not only do you know that it’s a T, but you also know exactly what you can do with that T (and what you can’t). Remember, the whole point is to use the typechecker to stop you from doing invalid things. And the way the typechecker knows what’s valid and what’s not is by looking at the types you’re using and how you’re using them.

You can also define your own type:

```tsx
type Programmer = {
  /**
   * The full name of the Programmer
   */
  name: string;
  /**
   * This Programmer is known for what?
   */
  knownFor: string[];
};

const ada: Programmer = {
  name: 'Ada Lovelace',
  knownFor: ['Mathematics', 'Computing', 'First Programmer'],
};
```

Comments you see above are docstring comments.

Here's what typescript's type hierarchy looks like:

![](type-hierarchy.png)

Say you have a function that takes some value and returns that value multiplied by itself:

```tsx
function squareOf(n) {
  return n * n;
}
// squareOf(2) evaluates to 4
// squareOf('z') evaluates to NaN
```

Clearly, this function will only work for numbers—if you pass anything besides a number to squareOf, the result will be invalid. So what we do is explicitly annotate the parameter’s type:

```tsx
function squareOf(n: number) {
  return n * n;
}
```

We can say the following things about the last code example:

1. squareOf’s parameter n is constrained to number.

2. The type of the value 2 is assignable to (equivalently: compatible with) number.

Without a type annotation, squareOf is unconstrained in its parameter, and you can pass any type of argument to it. Once we constrain it, TypeScript goes to work for us verifying that every place we call our function, we call it with a compatible argument.

### any

any is the Godfather of types. It does anything for a price, but you don’t want to ask any for a favor unless you’re completely out of options. In TypeScript everything needs to have a type at compile time, and any is the default type when you (the pro‐ grammer) and TypeScript (the typechecker) can’t figure out what type something is. It’s a last resort type, and you should avoid it when possible. any is the set of all values, and you can do anything with any. That means that if you have a value of type any you can add to it, multiply by it, call .pizza() on it—anything.

```tsx
let a: any = 666; // any
let b: any = ['danger']; // any
let c = a + b; // any
```

Using any in the above, no errors are thrown! My compiler returned this:

```tsx
666danger
```

### unknown

For the few cases where you have a value whose type you really don’t know ahead of time, don’t use any, and instead reach for unknown. Like any, it represents any value, but TypeScript won’t let you use an unknown type until you refine it by checking what it is. (more on refinement later)

### boolean

```tsx
leta = true;
var b = false;
const c = true;
let d: boolean = true;
let e: true = true;
let f: true = false; // Error TS2322: Type 'false' is not assignable to type 'true'.
```

`e` isn’t just any old boolean—it’s the specific boolean true. By using a value as a type, we essentially limited the possible values for `e` and `f` from all booleans to one specific boolean each. This feature is called **type literals**.

**type literal** : A type that represents a single value and nothing else

### number

number is the set of all numbers: integers, floats, positives, negatives, Infinity, NaN, and so on. Numbers can do, well, numbery things, like addition (+), subtraction (-), modulo (%), and comparison (<).Example:

```tsx
let a = 1234;
var b = Infinity * 0.1;
const c = 5678;
let d = a < b; //bool
let e: number = 100;
let f: 26.218 = 26.218; // 26.218
f = 27; // Type '27' is not assignable to type '26.218'
let g: 26.218 = 10; // Error TS2322: Type '10' is not assignable to type '26.218'.
```

### objects

TypeScript’s object types specify the shapes of objects. If you try this:

```tsx
let a: object = { b: 'x' };
```

you'll get an error saying: `Property 'b' does not exist on type 'object'`. Wait, that’s not very useful! What’s the point of typing something as an object if you can’t do anything with it? `object` is a little narrower than any, but not by much. object doesn’t tell you a lot about the value it describes, just that the value is a JavaScript object (and that it’s not null).

You can do 2 things:

- Leave off the `object`:

```tsx
let a = { b: 'x' };
```

- Explicitly provide type for `b`:

```tsx
let a: { b: string } = {
  b: 'hello!',
};
console.log(a.b);
```

This is called `object literal` syntax. Object literal syntax says, “Here is a thing that has this shape.” The thing might be an object literal, or it might be a class:

```tsx
let a: { firstName: string; lastName: string } = {
  firstName: 'john',
  lastName: 'barrowman',
};
class Person {
  constructor(public firstName: string, public lastName: string) {}
}
a = new Person('matt', 'smith'); // OK
```

`{firstName: string, lastName: string}` describes the shape of an object, and both the object literal and the class instance from the last example satisfy that shape, so TypeScript lets us assign a Person to `a`.

Can you tell TypeScript that something is optional, or that there might be more properties than you planned for? You bet:

```tsx
let a: {
  b: number; // 1
  c?: string; // 2
  [key: number]: boolean; // 3
};
```

`a`:

1. has property `b` that is a number

2. might have a property `c` that is string that is optional. And if `c` exists, it might be undefined

3. might have any number of numeric properties that are booleans. This too is optional

Example:

```tsx
a = { b: 1, c: undefined, 10: true, 20: false, 30: true };
a = { b: 1, c: undefined };
a = { b: 1, c: 'd' };
a = { b: 1, 10: true };
a = { b: 1, 10: true, 20: false };
```

The `[key: T]: U` `([key: number]: boolean)` syntax is called an **index signature**, and this is the way you tell TypeScript that the given object might contain more keys. The way to read it is, “For this object, all keys of type T (`number` in our example) must have values of type U (`boolean` in our example).” Index signatures let you safely add more keys to an object, in addition to any keys that you explicitly declared. What this means is that for `a`, if you have a number on the left, then it must have a boolean assigned:

```tsx
// not ok:
let a: {
  b: number;
  c?: string;
  2: string; // <-- NO!
  [key: number]: boolean;
};
```

Error for above will be: `Property '2' of type 'string' is not assignable to 'number' index type 'boolean'.ts(2411)`

```tsx
// this is ok:
let a: {
  b: number;
  c?: string;
  2: boolean;
  5: boolean;
  [key: number]: boolean;
};

a = { b: 1, c: undefined, 10: true, 20: false, 2: true, 5: false };
```

There is one rule to keep in mind for index signatures: the index signature key’s type, T, must be assignable to either number or string. More on index signatures [here](https://basarat.gitbook.io/typescript/type-system/index-signatures).

Let's look at another index signature example: say you want to make sure that anything that is stored in an object using a string conforms to the structure `{message: string}`. This can be done with the declaration `{ [index:string] : {message: string} }`. This is demonstrated below:

```tsx
let foo: { [index: string]: { message: string } } = {};

/**
 * Must store stuff that conforms to the structure
 */
/** Ok */
foo['a'] = { message: 'some message' };
/** Error: must contain a `message` of type string. You have a typo in `message` */
foo['a'] = { messages: 'some message' };

/**
 * Stuff that is read is also type checked
 */
/** Ok */
foo['a'].message;
/** Error: messages does not exist. You have a typo in `message` */
foo['a'].messages;
```

Also note that you can use any word for the index signature key’s name—it doesn’t have to be key:

```tsx
let airplaneSeatingAssignments: { [seatNumber: string]: string } = {
  '34D': 'Boris Cherny',
  '34E': 'Bill Gates',
};
```

You can also have lists as type. Say for example, I have an object representing different age groups:

```tsx
let ageGroups: {
  [groupName: string]: number[];
} = {};

ageGroups['under18s'] = [17, 16, 15, 14, 13];
```

What you see above is an object literal notation special case: empty object types: `{}`. Every type except null and undefined is assignable to an empty object type, which can make it tricky to use. Try to avoid empty object types when possible! A better way to redo the prev example would be:

```tsx
let ageGroups: {
  [groupName: string]: number[];
} = { under18s: [17, 16, 15, 14, 13] };
```

Other examples to avoid:

```tsx
let danger: {};
danger = {};
danger = { x: 1 };
danger = [];
danger = 2;
```

To summarize, here are the ways to declare objects in TypeScript:

1. They can be anonymous:.

```tsx
greet({ name: 'you', age: 12 });
function greet(person: { name: string; age: number }) {
  return 'Hello ' + person.name;
}
```

2. They can be named by using either an interface:

```tsx
interface Person {
  name: string;
  age: number;
}

const me: Person = {
  name: 'you',
  age: 12,
};

greet(me);

function greet(person: Person) {
  console.log('Hello ' + person.name + "'re: " + person.age);
}
```

3. or a type alias:

```tsx
type Person = {
  name: string;
  age: number;
};

function greet(person: Person) {
  return 'Hello ' + person.name;
}
```

### type aliases

It’s common to want to use the same type more than once and refer to it by a single name. To do so, we can create an "alias": - a name for any type. The syntax for a type alias is:

```tsx
type Point = {
  x: number;
  y: number;
};

function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 100, y: 100 });
```

Type aliases are useful for DRYing up repeated complex types,5 and for making it clear what a variable is used for.

### union and intersection types

If you have two things A and B, the union of those things is their sum (everything in A or B or both), and the intersection is what they have in common (everything in both A and B). TypeScript gives us special type operators to describe unions and intersections of types: `|` for union and `&` for intersection. Since types are a lot like sets, we can think of them in the same way. Let's look at an example:

```tsx
type Cat = { name: string; purrs: boolean; social: boolean };
type Dog = { name: string; wags: boolean; barks: boolean };
type CatAndDog = Cat & Dog;
type CatOrDogOrBoth = Cat | Dog;
```

If something is a CatOrDogOrBoth, what do you know about it? You know that it has a name property that’s a string, and not much else. On the flip side, what can you assign to a CatOrDogOrBoth? Well, a Cat, a Dog, or both:

```tsx
const fourLeggedCat: CatOrDogOrBoth = {
  name: 'cat',
  purrs: true,
  social: false,
};

const fourLeggedDog: CatOrDogOrBoth = {
  name: 'dog',
  wags: true,
  barks: true,
};

const fourLeggedBoth: CatOrDogOrBoth = {
  name: 'catdog',
  wags: true,
  barks: true,
  purrs: true,
  social: false,
};
```

This is worth reiterating: a value with a union type `|` isn’t necessarily one specific member of your union; in fact, it can be both members at once!

On the other hand, what do you know about CatAndDog? Not only does your canine, feline hybrid super-pet have a name, but it can purr, bark, and wag:

```tsx
const kittyRocky: CatAndDog = {
  name: 'kittyRocky',
  purrs: true,
  social: false,
  wags: true,
  barks: true,
};
```

### arrays

Like in JavaScript, TypeScript arrays are special kinds of objects that support things like concatenation, pushing, searching, and slicing. TypeScript supports two syntaxes for arrays: `T[]` and `Array<T>`. They are identical both in meaning and in performance.

```tsx
let a = [1, 2, 3]; // number[]
var b = ['a', 'b']; // string
let c: string[] = ['a']; //string
let d = [1, 'a']; // (number | string)[]
const e = [2, 'b']; // (number | string)[]
let f = ['red'];
f.push('blue');
// Error TS2345: Argument of type 'true' is not
// assignable to parameter of type 'string':
f.push(true);
```

We initialized `f` with the string 'red'. We then pushed 'blue' onto it; 'blue' is a string, so TypeScript let it pass. Then we tried to push true onto the array, but that failed! Why? Because `f` is an array of strings, and true is not a string.

On the other hand, when we initialized `d`, we gave it a number and a string, so TypeScript inferred that it must be an array of type number `|` string. Because each element might be either a number or a string, you have to check which it is before using it. Like with objects, creating arrays with const won’t hint to TypeScript to infer their types more narrowly. That’s why TypeScript inferred both d and e to be arrays of number | string.

`g` below is the special case: when you initialize an empty array, TypeScript doesn’t know what type the array’s elements should be, so it gives you the benefit of the doubt and makes them any. As you manipulate the array and add elements to it, TypeScript starts to piece together your array’s type. Once your array leaves the scope it was defined in (for example, if you declared it in a function, then returned it), TypeScript will assign it a final type that can’t be expanded anymore:

```tsx
let g = []; // any[]
g.push(1); // number[]
g.push('red'); // string []
```

### tuples

Tuples are subtypes of array. They’re a special way to type arrays that have fixed lengths, where the values at each index have specific, known types. Unlike most other types, tuples have to be explicitly typed when you declare them. That’s because the JavaScript syntax is the same for tuples and arrays (both use square brackets), and TypeScript already has rules for inferring array types from square brackets:

```tsx
let a: [number] = [1];
// A tuple of [first name, last name, birth year]
let b: [string, string, number] = ['malcolm', 'gladwell', 1963];

// Error TS2322: Type 'string' is not assignable to type 'number':
b = ['queen', 'elizabeth', 'ii', 1926];
```

Tuples also support rest elements, which you can use to type tuples with minimum lengths:

```tsx
// A list of strings with at least 1 element
let friends: [string, ...string[]] = ['Sara', 'Tali', 'Chloe', 'Claire'];

// A heterogeneous list
let list: [number, boolean, ...string[]] = [1, false, 'a', 'b', 'c'];
```

### null, undefined, void, and never

JavaScript has two values to represent an absence of something: `null` and `undefined`. TypeScript supports both of these as values, and it also has types for them: `null` and `undefined`. They’re both special types, because in TypeScript the only thing of type undefined is the value `undefined`, and the only thing of type null is the value `null`.

`undefined` means that something hasn’t been defined yet.

`null` means an absence of a value (like if you tried to compute a value, but ran into an error along the way).

In addition to `null` and `undefined`, TypeScript also has `void` and `never`. These are really specific, special-purpose types that draw even finer lines between the different kinds of things that don’t exist:

- `void` is the return type of a function that doesn’t explicitly return anything (for example, console.log)
- `never` is the type of a function that never returns at all (like a function that throws an exception, or one that runs forever)

### enums

Enums are a way to enumerate the possible values for a type. They are unordered data structures that map keys to values. Think of them like objects where the keys are fixed at compile time, so TypeScript can check that the given key actually exists when you access it.

By convention, enum names are uppercase and singular. Their keys are also uppercase.

```tsx
enum Frequency {
  Monthly,
  Daily,
  Weekly,
}
console.log(frequency.MONTHLY);
```

TypeScript will automatically infer a number as the value for each member of your enum, but you can also set values explicitly. Let’s make explicit what TypeScript inferred in the previous example:

```tsx
enum Frequency {
  Monthly = 0,
  Daily = 1,
  Weekly = 2,
}
```

To retrieve a value from an enum, you access it with either dot or bracket notation— just like you would to get a value from a regular object:

```tsx
let monthly = Frequency.Monthly;
let daily = Frequency['Daily'];
```

You can also use string values for enums, or even mix string and number values:

```tsx
enum Color {
  Red = '#c10000',
  Blue = '#007ac1',
  Pink = 0xc10050, // A hexadecimal literal
  White = 255, // decimal literal
}
```

```tsx
let a = Color.Red;
// Error TS2339: Property 'Green' does not exist
// on type 'typeof Color'.
let b = Color.Green;
// string
let c = Color[0];
// string (!!!) <--- UNSAFE!!
let d = Color[6];
```

Use `const` so that it's safer:

```tsx
const enum Color {
  Red = '#c10000',
  Blue = '#007ac1',
  Pink = 0xc10050, // A hexadecimal literal
  White = 255, // decimal literal
}
```

Accessing a valid enum would now require a string literal:

```tsx
// Error TS2476: A const enum member can only be
// accessed using a string literal.
Color[0];
Color.Red;
```

### record types

The `Record<Keys, Type>` type is a type that can ensure consistency in implementing a dictionary (key-value pairs) with fixed values/type for Keys and a defined type for the values. Record types keys have to be unique.

```tsx
interface CatInfo {
  age: number;
  breed: string;
}

type CatName = 'miffy' | 'boris' | 'mordred';

const cats: Record<CatName, CatInfo> = {
  miffy: { age: 10, breed: 'Persian' },
  boris: { age: 5, breed: 'Maine Coon' },
  mordred: { age: 16, breed: 'British Shorthair' },
};

console.log(cats.boris.age);
```

In short, TypeScript comes with a bunch of built-in types. You can let TypeScript infer types for you from your values, or you can explicitly type your values. const will infer more specific types, let and var more general ones.

## functions

In JavaScript, functions are first-class objects. That means you can use them exactly like you would any other object: assign them to variables, pass them to other func‐ tions, return them from functions, assign them to objects and prototypes, write prop‐ erties to them, read those properties back, and so on. There is a lot you can do with functions in JavaScript, and TypeScript models all of those things with its rich type system.

Here’s what a function looks like in TypeScript:

```tsx
function doubleIt(x: number) {
  return 2 * x;
}
```

You will usually explicitly annotate function parameters (a and b in this example)— TypeScript will always infer types throughout the body of your function, but in most cases it won’t infer types for your parameters, except for a few special cases where it can infer types from context (contextual typing later). The return type is inferred, but you can explicitly annotate it too if you want:

```tsx
function doubleIt(x: number): number {
  return 2 * x;
}
```

The last example used named function syntax to declare the function. TypeScript supports the following ways to do this:

1. Named function

```tsx
function greet(name: string) {
  return 'hello ' + name;
}
```

2. Function Expression

```tsx
let greet2 = function (name: string) {
  return 'hello ' + name;
};
```

3. Arrow Function Expression

```tsx
let greet3 = (name: string) => {
  return 'hello ' + name;
};
```

4. Shorthand Arrow function expression

```tsx
let greet4 = (name: string) => 'hello ' + name;
```

### optional and default parameters

Like in object and tuple types, you can use `?` to mark parameters as optional. When declaring your function’s parameters, required parameters have to come first, followed by optional parameters:

```tsx
function log(message: string, userId?: string) {
  let time = new Date().toLocaleTimeString();
  console.log(time, message, userId || 'Not signed in');
}
```

You can provide default values for optional parameters. Semantically it’s similar to making a parameter optional, in that callers no longer have to pass it in (a difference is that default parameters don’t have to be at the end of your list of parameters, while optional parameters do):

```tsx
function withOptional(id: number, name = 'default name', age?: number) {
  console.log('id: ' + id + ' name: ' + name + ' age: ' + (age ? age : 21));
}

// id: 123 name: Provided Name age: 18
withOptional(123, 'Provided Name', 18);
// id: 123 name: Provided Name age: 21
withOptional(123, 'Provided Name');
// id: 123 name: default name age: 21
withOptional(123);
```

Notice how when we give name a default value, we remove its optional annotation, `?`. We also don’t have to type it anymore. TypeScript is smart enough to infer the parameter’s type from its default value, keeping our code terse and easy to read.

Order is: required params > ones with default params > optional params

### rest parameters

Sometimes, you might opt for a variadic function API—one that takes a variable number of arguments—instead of a fixedarity API that takes a fixed number of arguments. For variadic functions, you use rest parameters:

```tsx
showRest(1, 2, 3, 4, 5);

function showRest(...scores: number[]) {
  let total = 0;
  scores.forEach((score) => {
    total += score;
  });
  console.log('final score is: ', total);
}
```

Notice how we're not passing in an array BUT a variable number (no pun intended!) of numbers! `scores` is NOT of type array of numbers but is a rest parameter that accepts an unfixed number of numbers.

A function can have at most one rest parameter, and that parameter has to be the last one in the function’s parameter list.

### call signatures

Let's talk about how we can express the full types of functions. Let’s look at a `sum` function:

```tsx
function sum(a: number, b: number): number {
  return a + b;
}
```

What is the type of `sum`? Well, sum is a function, so its type is: `Function`

The Function type is not what you want to use most of the time. Like `object` describes all objects, `Function` is a catchall type for all functions, and doesn’t tell you anything about the specific function that it types.

How else can we type sum? sum is a function that takes two numbers and returns a number. In TypeScript we can express its type as:

```tsx
// function sum(a: number, b: number): number {
//   return a + b;
// }
(a: number, b: number) => number;
```

This is TypeScript’s syntax for a function’s type, or call signature (also called a type signature). You’ll notice it looks remarkably similar to an arrow function—this is intentional! When you pass functions around as arguments, or return them from other functions, this is the syntax you’ll use to type them. The parameter names a and b just serve as documentation, and don’t affect the assignability of a function with that type.

Function call signatures only contain type level code: that is, types only, no values.

Let’s go through a few of the examples of functions and pull out their types into standalone call signatures that we’ll bind to type aliases:

```tsx
// function greet(name: string)
type Greet = (name: string) => string;

// function log(message: string, userId?: string)
type Log = (message: string, userId?: string) => void;

// function sumVariadicSafe(...numbers: number[]): number
type SumVariadicSafe = (...numbers: number[]) => number;
```

The functions’ call signatures (type level code) look remarkably similar to their implementations. This is intentional, and is a language design choice that makes call signatures easier to reason about.

Let’s make the relationship between call signatures and their implementations more concrete. If you have a call signature, how can you declare a function that implements that signature? You simply combine the call signature with a function expression that implements it.

Using the type `Log` from earlier, here's what we can do:

```tsx
type Log = (message: string, userId?: string) => void;

let log: Log(
  message,
  userId =  'defaultUserId'
) => {
  let time = new Date().toISOString()
  console.log(time, message, userId)
}
```

1.  We declare a function expression `log`, and explicitly type it as type `Log`.

2.  We don’t need to annotate our parameters twice. Since message is already annotated as a string as part of the definition for `Log`, we don’t need to type it again here. Instead, we let TypeScript infer it for us from `Log`.

3.  We add a default value for `userId`, since we captured userId’s type in our signature for `Log`, but we couldn’t capture the default value as part of `Log` because `Log` is a type and can’t contain values.

4.  We don’t need to annotate our return type again, since we already declared it as void in our Log type.

Let's look at another example using the type `SumVariadicSafe` from earlier. Here's what we can do:

```tsx
type SumVariadicSafe = (...scores: number[]) => number;

let sumIt: SumVariadicSafe = (...scores) => {
  let total = 0;
  scores.forEach((score) => {
    total += score;
  });
  return total;
};
```

1. We declare a function expression `sumIt`, and explicitly type it as type `SumVariadicSafe`.
2. We don’t need to annotate our parameters twice. Since scores is already annotated as a rest parameter as part of the definition for `SumVariadicSafe`, we don’t need to type it again here. Instead, we let TypeScript infer it for us from `SumVariadicSafe`.

### contextual typing

Because we already declared that log is of type `Log`, TypeScript is able to infer from context that message has to be of type string. This is a powerful feature of TypeScript’s type inference called contextual typing.
Let’s declare a function `times` that calls its callback `f` some number of times `n`, passing the current index to `f` each time: (“callback” is a function that you passed as an argument to another function.)

```py
function times(
  f: (index: number) => void,
  n: number
) {
    for (let i = 0; i < n; i++) {
      f(i);
    }
}
```

When you call times, you don’t have to explicitly annotate the function you pass to times if you declare that function inline:

```tsx
times((n) => console.log(n), 4);
```

### overloaded functions

What we saw earlier is also called shorthand signature. There's also a full call signature that does exactly the same thing:

```tsx
// Shorthand call signature
type Log = (message: string, userId?: string) => void;

// Full call signature
type Log = {
  (message: string, userId?: string): void;
};
```

For simple cases like our `Log` function, you should prefer the shorthand; but for more complicated functions, there are a few good use cases for full signatures. The first of these is overloading a function type: **overloaded function** is a function with multiple call signatures. You can use overloaded function signatures to design really expressive APIs. For example, let’s design an API to book a vacation—we’ll call it Reserve. Let’s start by sketching out its types (with a full type signature this time):

```tsx
type Reserve = {
  (from: Date, to: Date, destination: string): Reservation;
};
```

Let’s then stub out an implementation for Reserve:

```tsx
let reserve: Reserve = (from, to, destination) => {
  // ...
};
```

So a user who wants to book a trip to Bali has to call our reserve API with a from date, a to date, and "Bali" as a destination. We might repurpose our API to support one-way trips too:

```tsx
type Reservation = {
  from: Date;
  to?: Date;
  destination: String;
  message: String;
};

type Reserve = {
  // Signature1
  (from: Date, to: Date, destination: string): Reservation;
  // Signature2
  (from: Date, destination: string): Reservation;
};

let oneWayToBali: Reserve = (from, to, destination) => {
  return {
    from: from,
    to: to,
    destination: destination,
    message: 'Thank you for flying to ' + to + ' from ' + from + ' with us!',
  };
};
```

For the above, `oneWayToBali` will return an error saying:

```tsx
Type '(from: Date, to: Date, destination: string) => { from: Date; to: Date; destination: string; message: string; }'
is not assignable to type 'Reserve'.ts(2322)
```

This is because of the way call signature overloading works in TypeScript. If you declare a set of overload signatures for a function `f`, from a caller’s point of view `f`’s type is the union of those overload signatures. But from `f`’s implementation’s point of view, there needs to be a single, combined type that can actually be implemented. You need to manually declare this combined call signature when implementing `f`, it won’t be inferred for you. For our Reserve example, we can update our reserve function like this:

```tsx
// From:
type Reserve = {
  (from: Date, to: Date, destination: string): Reservation;
  (from: Date, destination: string): Reservation;
};
// To:
type Reserve = {
  (from: Date, toOrDestination: Date, destination?: string): Reservation;
};
```

The implementation’s new signature is the result of us manually combining the two overload signatures (in other words, we computed `Signature1` | `Signature2` by hand). Note that the combined signature isn’t visible to functions that call reserve; from a consumer’s point of view, Reserve’s signature is:

```tsx
type Reserve = {
  (from: Date, to: Date, destination: string): Reservation;
  (from: Date, destination: string): Reservation;
};
```

Here's a full example making use of the overloaded function. We have a one way trip to Bali and a round trip to Mexico:

```tsx
// Returned from Reserve
type Reservation = {
  from: Date;
  toOrDestination?: Date | String;
  message: String;
};

// Type to Reserve
type Reserve = {
  (from: Date, toOrDestination: Date | string, destination?: string): Reservation;
};

// Just some dates for testing
const today = new Date();
const to = new Date(today);
to.setDate(to.getDate() + 3);
```

Here's the main function. If you want a one way trip, pass in a string to `toOrDestination` and leave optional param `destination` undefined. If you want a round trip, provide to date for `toOrDestination` and ALSO provide `destination` param.

```tsx
/**
 * Function to make a reservation
 * @param from Date you want to leave
 * @param toOrDestination Could be date (to) for round trip or destination for 1 way
 * @param destination Optional param only to be defined if it is a round trip.
 * @returns Type Reservation
 */
let makeReservation: Reserve = (from, toOrDestination, destination): Reservation => {
  let message = 'Thanks for flying ';
  typeof toOrDestination == 'string'
    ? (message = message + 'one way to ' + toOrDestination + '. You leave: ' + from.toString())
    : (message =
        message +
        'round trip ' +
        destination +
        '. You leave: ' +
        from.toString() +
        ' and return ' +
        toOrDestination.toString());
  return {
    from: from,
    toOrDestination: toOrDestination,
    message: message,
  };
};

console.log(makeReservation(today, 'Bali').message);
console.log('**********');
console.log(makeReservation(today, to, 'Bali').message);
```

Since `makeReservation` might be called in either of two ways, when you implement `makeReservation` you have to prove to TypeScript that you checked how it was called (what I did with checking `toOrDestination`).

### polymorphism

So far, we've looked at concrete types: boolean, string, number etc. Concrete types are useful when you know precisely what type you’re expecting, and want to verify that type was actually passed. But sometimes, you don’t know what type to expect beforehand, and you don’t want to restrict your function’s behavior to a specific type!

As an example, let’s implement filter. You use filter to iterate over an array and refine it; in JavaScript, it might look like this:

```js
function filter(array, f) {
  let result = []
  for (let i = 0; i < array.length; i++) {
    let item = array[i] if (f(item)) {
      result.push(item)
    }
  }
  return result
}

filter([1, 2, 3, 4], _ => _ < 3) // evaluates to [1, 2]
```

Let’s start by pulling out filter’s full type signature, and adding some placeholder unknowns for the types:

```tsx
type Filter = {
  (array: unknown, f: unknown) => unknown[]
}
```

Now, let’s try to fill in the types with, say, number:

```tsx
type Filter = {
  (array: number[], f: (item: number) => boolean): number[];
};
```

Typing the array’s elements as number works well for this example, but filter is meant to be a generic function—you can filter arrays of numbers, strings, objects, other arrays, anything. The signature we wrote works for arrays of numbers, but it doesn’t work for arrays of other types of elements.

To make filter more useful, we'll use **generic types parameters**: It is nothing but a placeholder type used to enforce a type-level constraint in multiple places. Also known as polymorphic type parameter.

Going back to our filter example, here is what its type looks like when we rewrite it with a generic type parameter T:

```tsx
// Earlier:
type Filter = {
  (array: unknown, f: unknown) => unknown[]
}

//Generic:
type Filter = {
  <T>(array: T[], f: (item: T) => boolean): T[];
};
```

What this means is that our type `Filter` will accept an array of type `T`, an `f` function that accepts item of type `T` that returns a boolean and finally our `Filter` will return an array of `T`s.

This function filter uses a generic type parameter T; we don’t know what this type will be ahead of time, so we let TypeScript infer what it is each time we call filter. TypeScript infers T from the type we pass in for array. Once TypeScript infers what T is for a given call to filter, it substitutes that type in for every T it sees. T is like a placeholder type, to be filled in by the typechecker from context; it parameterizes Filter’s type, which is why we call it a generic type parameter.

Because it’s such a mouthful to say “generic type parameter” every time, people often shorten it to just “generic type,” or simply “generic.”

The angle brackets, `<>`, are how you declare generic type parameters (think of them like the type keyword, but for generic types); where you place the angle brackets scopes the generics (there are just a few places you can put them), and TypeScript makes sure that within their scope, all instances of the generic type parameters are eventually bound to the same concrete types.
