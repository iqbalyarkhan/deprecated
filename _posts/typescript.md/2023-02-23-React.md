---
title: 'React'
date: 2023-02-23
tags:
  - react
---

## functions

Any time you want to perform some sort of repeatable task with JavaScript, you can use a function. Letâ€™s take a look at some of the different syntax options:

### function declarations

A function declaration or function definition starts with the `function` keyword, which is followed by the name of the function, `logCompliment`. The JavaScript statements that are part of the function are defined between the curly braces. Once youâ€™ve declared the function, youâ€™ll invoke or call it to see it execute:

```jsx
function letsPrint() {
  console.log('Lets print');
}
letsPrint();
```

Once invoked, youâ€™ll see the compliment logged to the console.

### function expression

Another option is to use a function expression. This just involves creating the function as a variable:

```jsx
const letsPrint = function () {
  console.log('Lets print');
};
letsPrint();
```

One thing to be aware of when deciding between a function declaration and a function expression is that function declarations are hoisted and function expressions are not: meaning you can invoke a function before you write a function declaration. You cannot invoke a function created by a function expression.

### passing arguments

The `letsPrint` function currently takes in no arguments or parameters. We can pass named parameters to a function simply by adding them to the parentheses. Letâ€™s start by adding a `firstName` variable:

```tsx
const letsPrint = function (firstName: string) {
  console.log(`Hello ${firstName}`);
};

letsPrint('Billy');
```

Now when we call the `letsPrint` function, the `firstName` value sent will be added to the console message. Notice how we need to provide the "type" for this variable. We could add to this a bit by creating another argument called message. Now, we wonâ€™t hard-code the message. Weâ€™ll pass in a dynamic value as a parameter:

```tsx
const letsPrint = function (firstName: string, message: string) {
  console.log(`${message} ${firstName}`);
};

letsPrint('Billy', 'Hello!');
```

### function returns

Let's have our function return stuff:

```tsx
const letsPrint = function (firstName: string, message: string) {
  return `${message} ${firstName}`;
};

console.log(letsPrint('Billy', 'Hello!'));
```

### arrow functions

Arrow functions are a useful new feature of ES6. With arrow functions, you can create functions without using the function keyword. You also often do not have to use the return keyword. Letâ€™s consider a function that takes in a firstName and returns a string, turning the person into a soccer fan:

```tsx
const makeSoccerFan = (name: string) => `${name} is a soccer fan!`;
```

With the arrow, we now have an entire function declaration on one line. The function keyword is removed. We also remove return because the arrow points to what should be returned. We can keep this as a one-line function because there is only one statement that needs to be returned. If there are multiple lines, youâ€™ll use curly braces. Also, you can provide the return type from that function: `: string => `

```tsx
const myFunc = (name: string): string => {
  if (name) {
    return `${name} is a soccer fan!`;
  } else {
    return 'Not a soccer fan!';
  }
};
```

### returning objects

What happens if you want to return an object? Consider a function called person that builds an object based on parameters passed in for `firstName` and `lastName`:

```tsx
// Declared type person
type Person = {
  firstName: string;
  lastName: string;
};

// ? means it is optional
const getInfo = (firstName?: string, lastName?: string): Person => {
  if (firstName && lastName) {
    return {
      firstName: firstName,
      lastName: lastName,
    };
  } else {
    return {
      firstName: 'N/A',
      lastName: 'N/A',
    };
  }
};

console.log(JSON.stringify(getInfo('James', 'Bond')));
```

## objects and arrays

Since ES2016, JavaScript syntax has supported creative ways of scoping variables within objects and arrays. These creative techniques are widely used among the React community. Letâ€™s take a look at a few of them, including destructuring, object literal enhancement, and the spread operator.

### destructuring objects

Destructuring means picking and choosing only those fields that are of interest to you from an object. Say for example, we're passed an object of type `Person` with a person's `firstName`, `lastName` and age but we only want to display their fName and lName:

```tsx
type Person = {
  firstName: string;
  lastName: string;
  age: number;
};

const getInfo = ({ firstName, age }: Person) => {
  console.log(`You sent in: ${firstName}, ${age}`);
};

const myPerson: Person = {
  firstName: 'james',
  lastName: 'bond',
  age: 40,
};

getInfo(myPerson);
```

A new notation above:

- Typescript expects us to define the types we're extracting from the object. Thus this line:

```tsx
({ firstName, age }: Person)
```

Letâ€™s take this one level farther to reflect a data change. Now, the regularPerson object has a new nested object on the spouse key. So our new `Person` object is now this:

```tsx
type Person = {
  firstName: string;
  lastName: string;
  age: number;
  spouse: {
    firstName: string;
    lastName: string;
  };
};

const getInfo = ({ lastName, age, spouse: { firstName } }: Person) => {
  console.log(
    `Welcome Mr. ${lastName}, 
    aged ${age} and your wife: 
    ${firstName}`
  );
};

const myPerson: Person = {
  firstName: 'james',
  lastName: 'bond',
  age: 40,
  spouse: {
    firstName: 'eva',
    lastName: 'green',
  },
};

getInfo(myPerson);
```

### destructuring arrays

Values can also be destructured from arrays. Imagine that we wanted to assign the first value of an array to a variable name:

```tsx
const [a] = ['a', 'b', 'c'];
console.log(a); // a
```

We can also pass over unnecessary values with list matching using commas. List matching occurs when commas take the place of elements that should be skipped. With the same array, we can access the last value by replacing the first two values with commas:

```tsx
const [, , c] = ['a', 'b', 'c'];
console.log(c); // c
```

### object literal enhancement

This is the opposite of destructuring: ie reconstructing the object:

```tsx
const fName = 'james';
const lName = 'bond';
const print = function () {
  console.log(`${this.fName}, ${this.lName}`);
};

const actionHero = { fName, lName, print };
actionHero.print(); // Mt. Tallac is 9738 feet tall
```

Notice we use `this` to access the object keys. Another example:

```tsx
const skier = {
  name,
  sound,
  powerYell() {
    let yell = this.sound.toUpperCase();
    console.log(`${yell} ${yell} ${yell}!!!`);
  },
  speed(mph) {
    this.speed = mph;
    console.log('speed:', mph);
  },
};
```

Object literal enhancement allows us to pull global variables into objects and reduces typing by making the function keyword unnecessary.

### spread operator

The spread operator is three dots `(...)` that perform several different tasks. First, the spread operator allows us to combine the contents of arrays. For example, if we had two arrays, we could make a third array that combines the two arrays into one:

```tsx
const one = ['a', 'b', 'c'];
const two = ['d', 'e', 'f'];
const three = [...one, ...two];
```

We can also use the three-dot syntax to collect function arguments as an array. When used in a function, these are called rest parameters. Here, we build a function that takes in n number of arguments using the spread operator, then uses those arguments to print some console messages:

```tsx
function directions(...args) {
  let [start, ...remaining] = args;
  let [finish, ...stops] = remaining.reverse();

  console.log(`drive through ${args.length} towns`);
  console.log(`start in ${start}`);
  console.log(`the destination is ${finish}`);
  console.log(`stopping ${stops.length} times in between`);
}

directions('Truckee', 'Tahoe City', 'Sunnyside', 'Homewood', 'Tahoma');
```

The directions function takes in the arguments using the spread operator. The first argument is assigned to the start variable. The last argument is assigned to a finish variable using Array.reverse. We then use the length of the arguments array to disâ€ play how many towns weâ€™re going through. The number of stops is the length of the arguments array minus the finish stop.

The spread operator can also be used for objects:

```tsx
const morning = {
  breakfast: 'oatmeal',
  lunch: 'peanut butter and jelly',
};
const dinner = 'mac and cheese';
const backpackingMeals = { ...morning, dinner };
console.log(backpackingMeals);
// {
// breakfast: "oatmeal",
// lunch: "peanut butter and jelly",
// dinner: "mac and cheese"
// }
```

## asynchronous execution

So far, we've seen synchronous execution. Let's see how we can make async calls:

### fetch and promise

```tsx
import fetch from 'cross-fetch';
console.log(fetch('https://api.randomuser.me/?nat=US&results=1'));
```

We're fetching a response from an API using the `fetch` library.

Running the above returns: `Promise { <pending> }`. What does that mean?! The promise is an object that represents whether the async operation is pending, has been completed, or has failed. The pending promise represents a state before the data has been fetched. We need to chain on a function called .then(). This function will take in a callback function that will run if the previous operation was successful. The then method will invoke the callback function once the promise has resolved. In other words, fetch some data, then convert response to JSON:

```tsx
import fetch from 'cross-fetch';

fetch('//api.github.com/users/lquixada')
  .then((res) => {
    if (res.status >= 400) {
      throw new Error('Bad response from server');
    }
    return res.json();
  })
  .then((user) => {
    console.log(user);
  })
  .catch((err) => {
    console.error(err);
  });
```

You see this gets ugly! Too many `.then()` calls.

### async and await

Using `async` and `await` is preferred because it looks more familiar, like code thatâ€™s found in a synchronous function. Instead of waiting for the results of a promise to resolve and handling it with a chain of then functions, `async` functions can be told to wait for the promise to resolve before further executing any code found in the function.
Letâ€™s make another API request but wrap the functionality with an async function:

```tsx
// async function
const getInfo = async () => {
  try {
    //await the result
    const res = await fetch('//api.github.com/users/lquixada');

    if (res.status >= 400) {
      throw new Error('Bad response from server');
    }

    const user = await res.json();

    console.log(user);
  } catch (err) {
    console.error(err);
  }
};

getInfo();
```

Notice that the getFakePerson function is declared using the async keyword. This makes it an asynchronous function that can wait for promises to resolve before exeâ€ cuting the code any further. The await keyword is used before promise calls. This tells the function to wait for the promise to resolve.

## imperative vs declarative

Functional programming is a part of a larger programming paradigm: `declarative programming`. Declarative programming is a style of programming where applications are structured in a way that prioritizes **describing what should happen** over defining how it should happen.

Contrast that with imperative programming which is a style of programming thatâ€™s only concerned with how to achieve results with code. Let's start with the imperative approach (one you're comfortable with!):

First, letâ€™s examine an imperative approach to this task. Replace white space with a dash:

```tsx
const string = 'You are great';
const urlFriendly = '';
for (var i = 0; i < string.length; i++) {
  if (string[i] === ' ') {
    urlFriendly += '-';
  } else {
    urlFriendly += string[i];
  }
}
console.log(urlFriendly); // "You-are-great"
```

Here's declarative approach for the same:

```tsx
const string = 'You are great';
const urlFriendly = string.replace(/ /g, '-');
console.log(urlFriendly);
```

Here we are using string.replace along with a regular expression to replace all instances of spaces with hyphens. Using string.replace is a way of describing whatâ€™s supposed to happen: spaces in the string should be replaced. The details of how spaces are dealt with are abstracted away inside the replace function. In a declarative program, the syntax itself describes what should happen, and the details of how things happen are abstracted away. Declarative programs are easy to reason about because the code itself describes what is happening.

Now, letâ€™s consider the task of building a document object model, or `DOM`. An imperative approach would be concerned with how the `DOM` is constructed:

```tsx
const target = document.getElementById('target');
const wrapper = document.createElement('div');
const headline = document.createElement('h1');
wrapper.id = 'welcome';
headline.innerText = 'Hello World';
wrapper.appendChild(headline);
target.appendChild(wrapper);
```

This code is concerned with creating elements, setting elements, and adding them to the document. It would be very hard to make changes, add features, or scale 10,000 lines of code where the DOM is constructed imperatively.
Now letâ€™s take a look at how we can construct a DOM declaratively using a React component:

```tsx
const { render } = ReactDOM;
const Welcome = () => (
  <div id="welcome">
    <h1>Hello World</h1>
  </div>
);
render(<Welcome />, document.getElementById('target'));
```

React is declarative. Here, the Welcome component describes the `DOM` that should be rendered. The render function uses the instructions declared in the component to build the `DOM`, abstracting away the details of how the `DOM` is to be rendered. We can clearly see that we want to render our `Welcome` component into the element with the ID of `target`.

## React

React is a library thatâ€™s designed to update the browser DOM for us. We no longer have to be concerned with the complexities associated with building high-performing SPAs because React can do that for us. With React, we do not interact with the DOM API directly. Instead, we provide instructions for what we want React to build, and React will take care of rendering and reconciling the elements weâ€™ve instructed it to create. React elements are the instructions for how the browser DOM should be created.

### react DOM

Once weâ€™ve created a React element, weâ€™ll want to see it in the browser. ReactDOM contains the tools necessary to render React elements in the browser. ReactDOM is where weâ€™ll find the render method.
We can render a React element, including its children, to the DOM with `ReactDOM.render`. The element we want to render is passed as the first argument, and the second argument is the target node, where we should render the element.

The `dish` element below has 3 arguments:

- The first argument defines the type of element we want to create. In this case, we want to create an h1 element.

- The second argument represents the elementâ€™s properties. This h1 currently has an id of `id-0`.

- The third argument represents the elementâ€™s children: any nodes that are inserted between the opening and closing tag (in this case, just some text).

```tsx
const dish = React.createElement('h1', 'id-0', 'Baked Salmon');
const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render([dish, dessert]);
```

We build this div inside the body tag:

```tsx
<body>
  <div id="root">
    <h1 id="id-0">Baked Salmon</h1>{' '}
  </div>
</body>
```

You can also render multiple elements:

```tsx
const dish = React.createElement('h1', null, 'Baked Salmon');
const dessert = React.createElement('h2', null, 'Coconut Cream Pie');

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render([dish, dessert]);
```

## react rendering

Letâ€™s consider an unordered list that contains ingredients:

```tsx
<ul>
  <li>2 lb salmon</li>
  <li>5 sprigs fresh rosemary</li>
  <li>2 tablespoons olive oil</li>
  <li>2 small lemons</li>
  <li>1 teaspoon kosher salt</li> <li>4 cloves of chopped garlic</li>
</ul>
```

Here, the unordered list, `ul` is the root element, and it has six children (`li`). We can represent this `ul` and its children with `React.createElement`:

```tsx
const myElement = React.createElement(
  'ul',
  null,
  React.createElement('li', null, '2 lb salmon'),
  React.createElement('li', null, '5 sprigs fresh rosemary'),
  React.createElement('li', null, '2 tablespoons olive oil'),
  React.createElement('li', null, '2 small lemons'),
  React.createElement('li', null, '1 teaspoon kosher salt'),
  React.createElement('li', null, '4 cloves of chopped garlic')
);

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render(myElement);
```

If we were to inspect the resulting React element, we would see each list item represented by a React element and added to an array called props.children. If you console log this element, you'll see this:

```txt
{
  "type": "ul",
  "props": {
  "children": [
  { "type": "li", "props": { "children": "2 lb salmon" } ... },
  { "type": "li", "props": { "children": "5 sprigs fresh rosemary"} ... },
  { "type": "li", "props": { "children": "2 tablespoons olive oil" } ... },
  { "type": "li", "props": { "children": "2 small lemons"} ... },
  { "type": "li", "props": { "children": "1 teaspoon kosher salt"} ... },
  { "type": "li", "props": { "children": "4 cloves of chopped garlic"} ... }
  ]
}
```

The major advantage of using React is its ability to separate data from UI elements. Since React is just JavaScript, we can add JavaScript logic to help us build the React component tree. For example, ingredients can be stored in an array, and we can map that array to the React elements.
Letâ€™s go back and think about the unordered list for a moment:

```tsx
React.createElement(
  'ul',
  null,
  React.createElement('li', null, '2 lb salmon'),
  React.createElement('li', null, '5 sprigs fresh rosemary'),
  React.createElement('li', null, '2 tablespoons olive oil'),
  React.createElement('li', null, '2 small lemons'),
  React.createElement('li', null, '1 teaspoon kosher salt'),
  React.createElement('li', null, '4 cloves of chopped garlic')
);
```

The data used in list of ingredients above can easily be represented using a JavaScript array:

```tsx
const items = [
  '2 lb salmon',
  '5 sprigs fresh rosemary',
  '2 tablespoons olive oil',
  '2 small lemons',
  '1 teaspoon kosher salt',
  '4 cloves of chopped garlic',
];
```

We want to use this data to generate the correct number of list items without having to hard-code each one. We can map over the array and create list items for as many ingredients as there are:

```tsx
const items = [
  '2 lb salmon',
  '5 sprigs fresh rosemary',
  '2 tablespoons olive oil',
  '2 small lemons',
  '1 teaspoon kosher salt',
  '4 cloves of chopped garlic',
];

const finalList = React.createElement(
  'ul',
  null,
  items.map((item) => React.createElement('li', null, item))
);

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render(finalList);
```

This syntax creates a React element for each ingredient in the array. Each string is displayed in the list itemâ€™s children as text. The value for each ingredient is displayed as the list item.

When running this code, youâ€™ll see a console warning like:

```tsx
react.development.js:207 Warning: Each child in a list should have a unique "key" prop.
Check the top-level render call using <ul>. See https://reactjs.org/link/warning-keys for more information.
at li
```

When we build a list of child elements by iterating through an array, React likes each of those elements to have a key property. The key property is used by React to help it update the DOM efficiently. You can make this warning go away by adding a unique key property to each of the list item elements. You can use the array index for each ingredient as that unique value:

```tsx
const items = [
  '2 lb salmon',
  '5 sprigs fresh rosemary',
  '2 tablespoons olive oil',
  '2 small lemons',
  '1 teaspoon kosher salt',
  '4 cloves of chopped garlic',
];

const finalList = React.createElement(
  'ul',
  null,
  items.map((item) => React.createElement('li', { key: i }, item))
);

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render(finalList);
```

## jsx

In the previous section we used `React.createElement()` quite a lot! It is not a recommended approach. The only reason we talked about it was to understand what's going on behind the scenes. Instead, we should be using `jsx` syntax:

```tsx
const element = <h1>Hello, world!</h1>;
```

It is called `JSX`, and it is a syntax extension to JavaScript. We use it with React to describe what the UI should look like. It comes with the full power of JavaScript. React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.

Instead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called [components](#components) that contain both.

React doesnâ€™t require using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.

Converting the previous example to `JSX`, you get this:

```tsx
const items = [
  '2 lb salmon',
  '5 sprigs fresh rosemary',
  '2 tablespoons olive oil',
  '2 small lemons',
  '1 teaspoon kosher salt',
  '4 cloves of chopped garlic',
];
//old
/**const finalList = React.createElement(
  'ul',
  null,
  items.map((item) => React.createElement('li', { key: i }, item))
);*/

const listItems = items.map((item, i) => <li key={i}>{item}</li>);
const finalList = <ul>{listItems}</ul>;

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render(finalList);
```

We've created a new `listItems` variable:

```tsx
const listItems = items.map((item, i) => <li key={i}>{item}</li>);
```

that maps each array item to a `li` tag (with a unique key of-course!);

Next, we then created our final variable that will be rendered called `finalList` that creates an `ul` out of the `li`:

```tsx
const finalList = <ul>{listItems}</ul>;
```

Notice how `JSX` allows us to add HTML to JavaScript!

## components

No matter its size, its contents, or what technologies are used to create it, a user interâ€ face is made up of parts. Buttons. Lists. Headings. All of these parts, when put together, make up a user interface. In React, we describe each of these parts as a component. Components allow us to reuse the same structure, and then we can populate those structures with different sets of data.

When considering a user interface you want to build with React, we break down elements into reusable pieces. For example, the recipes in figure below have a title, ingredients list, and instructions. All are part of a larger recipe or app component. We could create a component for each of the highlighted parts: ingredients, instructions, and so on:

![](recipe.png)

This is a scalable solution! If we want to display one recipe or 10,000, our component structure will support this.

ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘ğŸš§ğŸ›‘
Let's create our first component:

```tsx
import React from 'react';
import './App.css';

function Button() {
  return <button>alert('You clicked me!')</button>;
}

function App() {
  return (
    <div className="App">
      <p>Learn React</p>
      <Button />
    </div>
  );
}

export default App;
```

A few things to note above:

- We have default component that's exported from this file called `App`
- We have another component called `Button`.

Notice how we use `Button` inside of `App`:

```tsx
<Button />
```

Also notice that the name of this new component needs to start with an upper case. React components are regular JavaScript functions, but their names must start with a capital letter or they wonâ€™t work!

## Event Handlers

You can respond to events by declaring event handler functions inside your components:

```tsx
function MyButton() {
  function handleClick() {
    alert('You clicked me!');
  }

  return <button onClick={handleClick}>Click me</button>;
}
```

Notice how `onClick={handleClick}` has no parentheses at the end! Do not call the event handler function: you only need to pass it down. React will call your event handler when the user clicks the button.

## State

Often, youâ€™ll want your component to â€œrememberâ€ some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add state to your component.

First, we need to import `useState` from `react`:

```tsx
import React from 'react';
import { useState } from 'react';
import './App.css';
```

Now you can declare a state variable inside your component:

```tsx
const [count, setCount] = useState(0);
```

You will get two things from `useState`: the current state (`count`), and the function that lets you update it (`setCount`). You can give them any names, but the convention is to call them like `[something, setSomething]`.

The first time the button is displayed, count will be 0 because you passed 0 to `useState()`. When you want to change state, call `setCount()` and pass the new value to it. Clicking this button will increment the counter:

```tsx
import React from 'react';
import { useState } from 'react';
import './App.css';

function Button() {
  const [count, setCount] = useState(0);
  function handleClick() {
    setCount(count + 1);
  }
  return <button onClick={handleClick}>'You clicked me: {count} times </button>;
}

function App() {
  return (
    <div className="App">
      <p>Learn React</p>
      <Button />
    </div>
  );
}

export default App;
```

Let's look at the update `Button` component:

```tsx
function Button() {
  const [count, setCount] = useState(0);
  function handleClick() {
    setCount(count + 1);
  }
  return <button onClick={handleClick}>'You clicked me: {count} times </button>;
}
```

- notice the `const` keyword while using the state
- notice there's another function called `handleClick` inside of `Button`.
- notice that we don't do this: `count = count + 1`, we just tell what to do with `count` and let `setCount` do the rest: `setCount(count + 1)`.

You can use the `Button` component as many times as you want and each `Button` will come with its own counter:

```tsx
import { useState } from 'react';
import React from 'react';
import './App.css';

function Button() {
  const [count, setCount] = useState(0);
  function handleClick() {
    setCount(count + 1);
  }

  return <button onClick={handleClick}> You clicked me {count} times! </button>;
}

function App() {
  return (
    <div className="App">
      <p>Learn React</p>
      <Button />
      <Button />
    </div>
  );
}

export default App;
```

Each button â€œremembersâ€ its own count state and doesnâ€™t affect other buttons.

## Hooks

Functions starting with `use` are called `Hooks`. `useState` is a built-in Hook provided by React. You can find other built-in Hooks in the [React API reference](https://beta.reactjs.org/reference/react). You can also write your own Hooks by combining the existing ones.

Hooks are more restrictive than regular functions. You can only call Hooks at the top level of your components (or other Hooks). If you want to use useState in a condition or a loop, extract a new component and put it there.

In the previous example, each `Button` had its own independent count, and when each button was clicked, only the count for the button clicked changed:

![](sharing_data_child.webp)

However, often youâ€™ll need components to share data and always update together.

To make both `Button` components display the same count and update together, you need to move the state from the individual buttons â€œupwardsâ€ to the closest component containing all of them. In our example, this closest component is `App`:

![](sharing_data_parent_clicked.webp)

Now when you click either button, the count in `App` will change, which will change both of the counts in `Button`. Hereâ€™s how you can express this in code.

1. Here is what we had:

```tsx
import { useState } from 'react';
import React from 'react';
import './App.css';

function Button() {
  const [count, setCount] = useState(0);
  function handleClick() {
    setCount(count + 1);
  }

  return <button onClick={handleClick}> You clicked me {count} times! </button>;
}

function App() {
  return (
    <div className="App">
      <p>Learn React</p>
      <Button />
      <Button />
    </div>
  );
}

export default App;
```

2. We need to move the state "up" to `App`:

```tsx
function Button() {
  return <button onClick={handleClick}> You clicked me {count} times! </button>;
}

function App() {
  const [count, setCount] = useState(0);
  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div className="App">
      <p>Learn React</p>
      <Button />
      <Button />
    </div>
  );
}

export default App;
```

3. Next, we need to pass the `count` and `setCount` state variables to the `Button` component. This is done just like how you'd pass a variable to a component. You also need to change the signature for `Button` component to accept `count` and `setCount`. The information you pass down like this is called `props`. `App` component contains the `count` state and the `handleClick` event handler, and passes both of them down as props to each of the buttons.

```tsx
function Button({ count, onClick }: any) {
  return <button onClick={onClick}> You clicked me {count} times! </button>;
}

function App() {
  const [count, setCount] = useState(0);
  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div className="App">
      <p>Learn React</p>
      <Button count={count} onClick={handleClick} />
      <Button count={count} onClick={handleClick} />
    </div>
  );
}

export default App;
```

Let's look at the `Button` component:

```tsx
function Button({ count, onClick }: any) {
  return <button onClick={onClick}> You clicked me {count} times! </button>;
}
```

- it is accepting variables: `{count, onClick}` of type `any`
- the button onClick calls the function passed in which is also called `onClick`.
- value of `count` is displayed as text in the button

From `App`:

```tsx
function App() {
  const [count, setCount] = useState(0);
  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div className="App">
      <p>Learn React</p>
      <Button count={count} onClick={handleClick} />
      <Button count={count} onClick={handleClick} />
    </div>
  );
}
```

- We initialize the state like before using `useState` and declare a `handleClick` function that updates the state
- We call `Button` with the state value and state updater function

When you click the button, the `onClick` handler fires. Each buttonâ€™s `onClick` prop was set to the `handleClick` function inside `App`, so the code inside of it runs. That code calls `setCount(count + 1)`, incrementing the `count` state variable. The new count value is passed as a prop to each button, so they all show the new value.

This is called â€œlifting state upâ€. By moving state up, weâ€™ve shared it between components.

With the above in place, your buttons will both reflect the updated value as you click on any button. I made mine a little fun where we start off from 10 and each click reduces the number. While the number > 0, we're healthy and at 0, we alert happy new year! `App` component stays the same:

```tsx
function Button({ count, onClick }: any) {
  return (
    <button onClick={onClick}>
      Remaining: {count > 0 ? count : '0'} {count > 0 ? 'old year' : 'happy new year!'}
    </button>
  );
}

function App() {
  const [count, setCount] = useState(10);

  function handleClick() {
    setCount(count - 1);
  }

  return (
    <div className="App">
      <p>Learn React</p>
      <Button count={count} onClick={handleClick} />
      <Button count={count} onClick={handleClick} />
    </div>
  );
}
```
