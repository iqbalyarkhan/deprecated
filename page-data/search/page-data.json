{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## Intro\n\nWe'll look at a few different \"types\" of networks present.\n\nThere's local networking that deals with how data moves between devices on your local network.\n\nThere's routing: how data moves from your network to another network (AWS, Netflix etc)\n\nWe'll look at how data is actually transmitted from one point to another (segmenting, ports and sessions).\n\n## OSI 7-Layer Model\n\nTo understand networks, we'll go through a conceptual model that is a stack of all the components that make networking possible. This model is called the OSI 7-Layer model:\n\n![OSI-Model](OSI-7-layers.jpeg)\n\nEach \"device\" capable of communicating with networks (ie connected to the internet!) will have a networking stack. Layers 1, 2 and 3 are called the media layers and the remaining are called host layers. Media layer is responsible for helping data move from point A to point B. Hosts layers are responsible for determining how data is chopped up and re-assembled.\n\nConceptually, data is sent from layer 7 of once machine (for example your browser), flows all the way down to layer 1 and back up to layer 7 on another machine (youtube server you're watching that video from!).\n\n## Layer 1 - Physical\n\nThis layer includes the physical equipment involved in the data transfer, such as the cables and switches. This is also the layer where the data gets converted into a bit stream, which is a string of 1s and 0s. You can think of this as a setup where 2 machines are connected via a cable or WIFI that communicate directly with each other.\n\n![layer-1](layer_1.png)\n\nAt this layer, the two connected machines agree on a standard where a certain voltage means Binary 1 and another means Binary 0. This allows the two connected machines to transmit data between each other.\n\n### Hub\n\nWhat if we want to add more machines to our system? Not just 2? We can use a layer 1 device called a 4 port hub (to connect 4 machines) to connect 4 machines with each other. The job of a hub is simple: anything received by the hub on any port is transmitted on every other port (including errors and collisions!). See issues here?\n\n- All data is processed by all devices (you can't direct data to a specific port/machine)\n- No way to prevent multiple devices from transmitting at once. So if 2 devices transmit at once, it will cause a collision. Also layer 1 cannot detect when a collision occurs. It lacks any intelligence.\n- No way to control which devices can transmit data\n\n## Layer 2 - Data Link Layer\n\nWe saw the limitations of layer 1 (no device to device communication, no collision avoidance, no transmission control) due to which we need layer 2. Layer 2 requires a functioning layer 1. Assume that for our example, layer 1 is running on ethernet.\n\n![layer-2](layer_2.png)\n\nLayer 2 sends information over a network using a concept called **frames**.\n\nDevices also have a unique hardware address called a **MAC address** for every device on a network. Addresses look like this: `3e:22:fb:b9:5b:75`. MAC address is attached to a specific piece of hardware.\n\nA MAC address consists of 2 parts, an OUI (organizationally unique identifier) which distinguishes one company from another. The other part is network interface controller (or NIC). This means MAC + NIC should result in a globally unique MAC address.\n\nKeep in mind that layer 1 doesn't understand frames or mac addresses. All it does is that it receives the data from layer 2, transmits it across to another device listening on layer 1, and then the data is moved on up to layer 2 of the receiver.\n\n### Frame\n\nA frame is composed of many parts:\n\n![frame](frame.png)\n\nThe first part is the preamble and start frame delimiter (SFD). It allows devices to know that this is the start of the frame. Preamble is 56 bits or 7 bytes (8 bits per byte) and SFD is 8 bits or 1 byte. A layer 2 receiver needs to know where the start of a frame is to make sense of the information contained within it.\n\nNext is the destination and source mac addresses. If you want to send to all devices on the local network, you put all Fs for destination aka broadcast. The source MAC address allows the sender to receive replies.\n\nNext is ether type (or type) that helps determine what layer 3 protocol is putting its data inside the frame. That's because layer 3 builds on top of layer 2 and uses layer 2 for device to device communication on a local network. When the receiver receives data, it needs to know the layer 3 protocol that put data into that frame.\n\nDestination MAC address, source MAC address and type are referred to as MAC header\n\nAfter the header, we have the payload which can range from 46 to 1500 bytes. This contains the data that the frame is sending which is generally provided by layer 3.\n\nAt the end there's the frame check sequence that is used to identify any errors in the frame. It allows the destination to check whether any corruption has occurred or not.\n\n### Layer 2 Complete Flow\n\nLet's checkout a complete flow:\n\n![recap](recap.png)[Credit: learn.cantrill.io](learn.cantrill.io)\n\nSay the machine on the left, let's call it L, needs to send data to machine on the right, R. L knows MAC address of R. L interacts with layer 2 software saying that it needs to send data to R via an ethernet. Data to be transmitted is stored in the payload part of the frame. Layer 2 can communicate with layer 1 the networking stack and it can look for the signs of a \"carrier\" signal. Layer 2 is looking to \"sense\" a carrier. A carrier signal means that there's already data in the signal and we don't want to corrupt existing data. This is the job of CSMA (carrier sense multiple access). If a carrier isn't detected, the frame is passed on to layer 1. This comes in handy in the scenario where R layer 2 is also trying to send data while L is transmitting. Detection of carrier signal will prompt R to wait until it gets the all clear.\n\nWhat if there was no carrier detected and both layer 2s transmitted data? Layer 2 contains collision detection. This is the job of collision detection where a jam signal is sent out by all devices that detected a collision. Then a random backoff occurs. This is random as it will allow a device at random to start transmitting again.\n\nLayer 1 doesn't understand what the frame is. It just receives the data from layer 2 and transmits it across. R side receives the data and passes it up to its layer 2. R layer 2 reviews destination mac address of the frame and passes it to R machine.\n\n![recap2](recap-2.png)[Credit: learn.cantrill.io](learn.cantrill.io)\n\nIn this approach we've encapsulated data into frames for transmission!\n\n### Switch\n\nNow remember our example from earlier in layer 1 where we had a hub that connected 4 devices? To do the same at layer 2, we use something called a switch! Hub was a layer 1 device and had layer 1 limitations. Switch is a layer 2 device and holds a great advantage over hubs! Let's say we have a machine at 12 O'clock (A) transmitting to machine at 3 O'Clock (B):\n\nBecause our devices are layer 2, each machine has its own mac address. Since a switch is a layer 2 device, it understands layer 2 mechanisms. Since each device on our network has a unique address, we need to keep track of those addresses. To do so, our switch keeps track of these addresses using something called a **mac address table (MAT)**. As switches receive traffic, they populate the MAT.\n\n![switch](switch-2.png)[Credit: learn.cantrill.io](learn.cantrill.io)\n\nNow let's assume that the MAT is populated and A needs to send data to B. It creates the frame and sends it over to the switch via layer 1. Switch sees the frame arrive at the port to which A is connected to. At this point 1 of 2 things will happen:\n\n- If switch didn't know which port the destination MAC address was on, it will forward this frame to all the ports\n- If switch does know which port the destination MAC address is attached to, it will use that one port to forward the frame\n\nSwitches also do not forward collisions therefore reducing the scope of collisions.\n\n![switch-2](switch-3.png)[Credit: learn.cantrill.io](learn.cantrill.io)\n","excerpt":"Intro We'll look at a few different \"types\" of networks present. There's local networking that deals with how data moves between devices on…","fields":{"slug":"/Networking/"},"frontmatter":{"date":"Feb 19, 2023","title":"Networking Foundations","tags":["Networking"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Intro\n\nEncryption is the method by which information is converted into secret code that hides the information's true meaning. The science of encrypting and decrypting information is called cryptography.\n\n**Unencrypted** data is **plaintext** (could be text, image, document etc)\n\n**Encrypted** data is **ciphertext** (could be text, image, document etc)\n\n**Encryption key** is similar to a password that is used to generate ciphertext\n\n**Algorithm** takes plaintext and an encryption key to create ciphertext. There are many algorithms that do this: AES, Blowfish, RC4 etc\n\nThe formulas used to encode and decode messages are called encryption algorithms, or ciphers. Process of encryption takes plaintext and a key and uses an algorithm to generate ciphertext. Decryption is the process of taking ciphertext and key to create plaintext.\n\n## Encryption at rest\n\nEncryption at rest is a type of encryption designed to prevent theft of sensitive data. This type of encryption is usually applied on hard-drives, cloud environment hardware etc. A \"secret\" is used to encrypt and decrypt the data. The secret is not to be shared with others. Only those that have knowledge of the secret would be able to decrypt the data\n\nUsually with this type of encryption, only a single party is involved that is responsible for encryption and decryption of the data.\n\n## Encryption in transit\n\nIn this type of encryption, data is encrypted as it is transferred between two parties. Party A (you) encrypt the data and send it to party B (your bank). Party B decrypts the data, performs some action, encrypts new data and returns this new data back to party A.\n\nThis type of encryption involves multiple systems or users.\n\n## Symmetric key encryption\n\n![symmetric](symmetric.jpeg)\n\nSay you have sender and receiver who want to exchange ciphertext with each other. They do the following:\n\n- Agree on an algorithm (AES-256 for example)\n- The sender takes plaintext and a symmetric encryption key and feeds it to AES-256 algorithm\n- Algorithm outputs ciphertext\n- Ciphertext is then transferred over to receiver\n- **The receiver needs to have the same key that was used to encrypt the data!**\n\nHow do we transfer the key that was used to encrypt the data?! This is why symmetric encryption is not ideal for encryption in transit. It is better suited for encrypting local data (hard drives, cloud servers etc). But just to complete the example above:\n\n- Receiver decrypts the ciphertext using the encryption key that was used\n\n## Asymmetric key encryption\n\n![asymmetric](asymmetric.webp)\n\nSay you have sender and receiver who want to exchange ciphertext with each other. They do the following:\n\n- Agree on an algorithm (public-key encryption or digital signatures for example)\n- The sender takes plaintext and creates asymmetric keys (notice plural!) for that algorithm. Asymmetric encryption uses 2 keys: a public key and a private key.\n- The public key is used to generate the ciphertext and this ciphertext is only decryptable by the private key! Public key cannot decrypt data that it was used to encrypt. The public key is made publicly available\n- The sender downloads the public key made available by the receiver. The sender then uses the public key to create ciphertext and transmit it to the receiver\n- The receiver already has the private key. Receiver provides the private key and cipher text to the algorithm and is able to read plaintext data.\n\nNotice in the flow above, no sensitive key exchange is required! Public key can be used by anyone to create ciphertext and send it to the receiver. But the receiver is the only person who has the private key and is able to decrypt the data.\n\nThis type of encryption is used when two or more parties are involved. This used by SSL or TLS encryption (browser communication) and SSH for example.\n\nAsymmetric encryption is computationally expensive so usually asymmetric encryption is used to exchange symmetric keys and then use symmetric encryption for further communication!\n\n## Signing\n\nSay the receiver has received the message and wants to respond with that confirmation via asymmetric encryption.One option is that the receiver can send an OK message. However, in asymmetric encryption, anyone can get sender's public key and use that to respond with an OK. Receiver can't be sure that the OK was from the intended receiver. This is where signing comes in.\n\nWith signing, the receiver can use their private key and sign that message. The receiver gets the message and it can then use the sender's public key to prove whether that message was signed by the intended receiver.\n\n![signing](signing.png)[Credit: learn.cantrill.io]\n\nKey signing is used for ID verification.\n","excerpt":"Intro Encryption is the method by which information is converted into secret code that hides the information's true meaning. The science of…","fields":{"slug":"/Encryption/"},"frontmatter":{"date":"Feb 16, 2023","title":"Encryption","tags":["Encryption","Security"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Intro\n\nWhen you sign up for AWS using your email and password, you're assigned a user called the `root` user. This user has unrestricted access to all resources in that account. If this account gets hacked, this account will be at the mercy of the hacker. The root user cannot be restricted. We want to be able to provide access to others that isn't without restrictions: for example, the BI department might need access to AWS QuickSight but not to AWS S3. This process of providing only required access is called Least Privileged Access. This is where IAM comes handy!\n\n## [IAM](https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html)\n\nIAM:\n\n- Is a global service that is globally resilient service. All data is replicated across all regions\n- Manages identities since it is an identity provider or **IDP**\n- Provides **authentication** (who is signed in?): I am who I say I am!\n- Provides **authorization** (who has permissions?) for AWS services. A service evaluates if an AWS request is allowed or denied. Access is denied by default and is allowed only when a policy explicitly grants access.\n\n## IAM Entities\n\n![users-groups-roles](users_groups_roles.png)\n\nUsing IAM, you can create IAM Users, IAM Groups and IAM Roles. Each have their own specific use-case:\n\n### IAM Users\n\nThe \"identity\" aspect of AWS Identity and Access Management (IAM) helps you with the question \"Who is that user?\", often referred to as authentication. Users are identities which represent humans that need access to your account. IAM users are not separate accounts; they are users within your account. Each user can have its own password for access to the AWS Management Console.\n\nIAM users are granted long term credentials to your AWS resources. As a best practice, you should require your human users to use temporary credentials when accessing AWS. You can use an identity provider for your human users to provide federated access to AWS accounts by assuming roles, which provide temporary credentials.\n\n### IAM Groups\n\nGroups are simply collections of related users. This is useful when you need to provide access to users who have similar roles in an org. For example, QuickSight access for all BAs in your BI group.\n\n### IAM Roles\n\nRoles help us provide permissions to:\n\n- AWS services to perform actions on our behalf. For example lambda in our account writing to S3 bucket in our account.\n- External services to our account. For example lambda in another account writing to S3 bucket in our account.\n\n### Best Practice\n\nAs a [best practice](https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html), require human users to use federation with an identity provider to access AWS using temporary credentials. An additional best practice recommendation is to require workloads to use temporary credentials with IAM roles to access AWS. IAM users are to be used only in very limited scenarios where an IAM role cannot be assumed.\n\n## IAM Policies\n\nHow does IAM actually \"attach\" these permissions to the entities listed above? That's where IAM policies come into picture. Policies are JSON documents that define deny or allow rights. On its own, a policy document does nothing. Only when it is attached to an entity does it take affect.\n","excerpt":"Intro When you sign up for AWS using your email and password, you're assigned a user called the  user. This user has unrestricted access to…","fields":{"slug":"/IAM/"},"frontmatter":{"date":"Feb 15, 2023","title":"IAM","tags":["IAM","AWS"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Intro\n\nTypescript is a strict syntactical superset of JavaScript and adds optional static typing to the language. It is designed for the development of large applications and transpiles to JavaScript.\n\n## Compiler\n\nLet's start at the compiler: programs are files that contain a bunch of text written by you, the programmer. That text is parsed by a special program called a compiler, which trans‐ forms it into an abstract syntax tree (AST), a data structure that ignores things like whitespace, comments, and where you stand on the tabs versus spaces debate. After the TypeScript Compiler generates an AST for your program—but before it emits code—it typechecks your code. The compiler then converts that AST to a lower-level representation called bytecode. You can feed that bytecode into another program called a runtime to evaluate it and get a result. So when you run a program, what you’re really doing is telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code.\n\nWhere TypeScript is special is that instead of compiling straight to bytecode, TS compiles to JavaScript code. You then run that JavaScript code like you normally would—in your browser, or with NodeJS.\n\nThis typechecking is the magic behind TypeScript. It’s how TypeScript makes sure that your program works as you expect, that there aren’t obvious mistakes.\n\n## The Type System\n\nTo explicitly signal to TypeScript what your types are, use annotations. Annotations take the form value: type and tell the typechecker, “Hey! You see this value here? Its type is type.” Let’s look at a few examples (the comments following each line are the actual types inferred by TypeScript):\n\n```tsx\nlet a: number = 1; // a is a number\nlet b: string = 'hello'; // b is a string\nlet c: boolean[] = [true, false]; // c is an array of booleans\n```\n\nAnd if you want TypeScript to infer your types for you, just leave them off and let TypeScript get to work:\n\n```tsx\nlet a = 1; // a is a number\nlet b = 'hello'; // b is a string\nlet c = [true, false]; // c is an array of booleans\n```\n\nTypeScript is a gradually typed language. That means that TypeScript works best when it knows the types of everything in your program at compile time, but it doesn’t have to know every type in order to compile your program. Even in an untyped pro‐ gram TypeScript can infer some types for you and catch some mistakes, but without knowing the types for everything, it will let a lot of mistakes slip through to your users. TypeScript statically analyzes your code for errors, and shows them to you before you run it.\n\n## tsconfig.json\n\nEvery TypeScript project should include a file called tsconfig.json in its root directory. This tsconfig.json is where TypeScript projects define things like which files should be compiled, which directory to compile them to, and which version of JavaScript to emit.\n\n```ts\n{\n  \"compilerOptions\": {\n    //Which APIs should TSC assume exist in the environment you’ll be running your code in? This includes things like ES5’sFunction.prototype.bind, ES2015’sObject.assign, and the DOM’s document.querySelector.\n    \"lib\": [\"es2015\"],\n    // Which module system should TSC compile your code to (CommonJS, SystemJS, ES2015, etc.)?\n    \"module\": \"commonjs\",\n    // Which folder should TSC put your generated JavaScript code in?\n    \"outDir\": \"dist\",\n    \"sourceMap\": true,\n    //Be as strict as possible when checking for invalid code. This option enforces that all of your code is properly typed. We’ll be using it for all of the examples in the book, and you should use it for your TypeScript project too.\n    \"strict\": true,\n    //Which JavaScript version should TSC compile your code to (ES3, ES5, ES2015, ES2016, etc.)?\n    \"target\": \"es2015\"\n  },\n  //# Which folders should TSC look in to find your TypeScript files?\n  \"include\": [\"src\"]\n}\n```\n\n## tslint.json\n\nYour project should also have a tslint.json file containing your TSLint configuration, codifying whatever stylistic conventions you want for your code (tabs versus spaces, etc.).\n\nThe following command will generate a tslint.json file with a default TSLint configuration:\n\n```bash\n./node_modules/.bin/tslint --init\n```\n\nYou can then add overrides to this to conform with your own coding style. For example, my tslint.json looks like this:\n\n```tsx\n{\n  \"defaultSeverity\": \"error\",\n  \"extends\": [\n      \"tslint:recommended\"\n  ],\n  \"rules\": {\n    \"semicolon\": false,\n    \"trailing-comma\": false\n  }\n}\n```\n\n## Component\n\nLet's look at our first react component:\n\n```tsx\nimport React from 'react';\nfunction App() {\n  //Do something\n  return (\n    <div>\n      <h1>Hello World</h1>\n    </div>\n  );\n}\n\nexport default App;\n```\n\nFirst, this React component, called `App` component, is just a JavaScript function. It’s commonly called function component, because there are other variations of React components.\n\nSecond, the App component doesn’t receive any parameters in its function signature yet. And third, the App component returns code that resembles HTML which is called JSX. The function component possess implementation details like any other JavaScript function (placeholder above is the //Do something comment).\n\nVariables defined in the function’s body will be re-defined each time this function runs, like all JavaScript functions:\n\n```tsx\nimport React from 'react';\nfunction App() {\n  const title = 'React';\n  return (\n    <div>\n      <h1>Hello World, this is ${title}</h1>\n    </div>\n  );\n}\nexport default App;\n```\n\nThe `title` variable can also be define outside the function. Running the above would print `Hello World, this is React`.\n\nLet's look at some more elements. An input field with a label can be defined as follows:\n\n```tsx\nimport React from 'react';\nconst title = 'React';\nfunction App() {\n  return (\n    <div>\n      <h1>Hello {title}</h1>\n      <label htmlFor=\"search\">Search: </label>\n      <input id=\"search\" type=\"text\" />\n    </div>\n  );\n}\nexport default App;\n```\n\nWe specified three HTML attributes here: htmlFor, id, and type. Where id and type should be familiar from native HTML, htmlFor might be new. The htmlFor reflects the for attribute in HTML. JSX replaces a handful of internal HTML attributes, but you can find all the supported HTML attributes33 in React’s documentation, which follow the camelCase naming convention.\n\nLet's modify our greeting a little:\n\n```tsx\nimport React from 'react';\n\nconst welcome = {\n  greeting: 'hey',\n  title: 'React',\n};\n\nfunction App() {\n  return (\n    <div>\n      <h1>\n        {welcome.greeting} {welcome.title}\n      </h1>\n      <label htmlFor=\"search\">Search: </label>\n      <input id=\"search\" type=\"text\" />\n    </div>\n  );\n}\nexport default App;\n```\n\nWe can also call functions from within the curly braces:\n\n```tsx\nimport React from 'react';\n\nfunction getGreeting() {\n  return 'hey React!';\n}\n\nfunction App() {\n  return (\n    <div>\n      <h1>{getGreeting()}</h1>\n      <label htmlFor=\"search\">Search: </label>\n      <input id=\"search\" type=\"text\" />\n    </div>\n  );\n}\nexport default App;\n```\n\n## Lists in React\n\nSo far we’ve rendered a few primitive variables in JSX; next we’ll render a list of items. We’ll experiment with sample data at first, then we’ll apply that to fetch data from a remote API. First, let’s define the array as a variable. As before, we can define a variable outside or inside the component. The following defines it outside:\n\n```tsx\n\nconst list = [\n  {\n    title: 'React',\n    url: 'https://reactjs.org/',\n    author: 'Jordan Walke',\n    num_comments: 3,\n    points: 4,\n    objectID: 0,\n  },\n  {\n    title: 'Redux',\n    url: 'https://redux.js.org/',\n    author: 'Dan Abramov, Andrew Clark',\n    num_comments: 2,\n    points: 5,\n    objectID: 1,\n  },\n];\nfunction App() {...}\nexport default App;\n```\n\nEach item in the list has a title, a url, an author, an identifier (objectID), points – which indicate the popularity of an item – and a count of comments. Next, we’ll render the list within our JSX dynamically:\n\n```tsx\nfunction App() {\n  return (\n    <div>\n      <h1>My Hacker Stories</h1>\n      <label htmlFor=\"search\">Search: </label>\n      <input id=\"search\" type=\"text\" />\n      <hr />\n      {/* render the list here */}\n    </div>\n  );\n}\n```\n\nBy assigning a key attribute to each list item’s element, React can identify modified items if the list changes (e.g. re-ordering). Fortunately, our list items come with an identifier:\n\n```tsx\nfunction App() {\n  return (\n    <div>\n      {' '}\n      ...\n      <hr />\n      {list.map(function (item) {\n        return <div key={item.objectID}>{item.title}</div>;\n      })}{' '}\n    </div>\n  );\n}\n```\n\nNote that we're using `item.ObjectID` as the `key` in our list. We avoid using the index of the item in the array to make sure the key attribute is a stable identifier. If the list changes its order, for example, React will not be able to identify the items properly. Here's what our code looks like right now:\n\n```tsx\nimport React from 'react';\n\nconst list = [\n  {\n    title: 'React',\n    url: 'https://reactjs.org/',\n    author: 'Jordan Walke',\n    num_comments: 3,\n    points: 4,\n    objectID: 0,\n  },\n  {\n    title: 'Redux',\n    url: 'https://redux.js.org/',\n    author: 'Dan Abramov, Andrew Clark',\n    num_comments: 2,\n    points: 5,\n    objectID: 1,\n  },\n];\n\nfunction getGreeting() {\n  return 'hey React!';\n}\n\nfunction App() {\n  return (\n    <div>\n      <h1>{getGreeting()}</h1>\n      <label htmlFor=\"search\">Search: </label>\n      <input id=\"search\" type=\"text\" />\n      <hr />\n      {list.map(function (item) {\n        return <div key={item.objectID}>{item.title}</div>;\n      })}{' '}\n    </div>\n  );\n}\nexport default App;\n```\n\nWe can display multiple fields from our list instead of just the title like so:\n\n```tsx\nfunction App() {\n  return (\n    <div>\n      <h1>{getGreeting()}</h1>\n      <label htmlFor=\"search\">Search: </label>\n      <input id=\"search\" type=\"text\" />\n      <hr />\n      {list.map(function (item) {\n        return (\n          <div key={item.objectID}>\n            <span>\n              <a href={item.url}>{item.title}</a>\n            </span>{' '}\n            written by {item.author}\n          </div>\n        );\n      })}{' '}\n    </div>\n  );\n}\n```\n\nThe component above is getting too complicated, let's create a new list component on its own. To do so, I'll export the list to its own file called `list.ts`. This is what our App component looks like:\n\n```tsx\nimport { List } from './List';\n\nfunction getGreeting() {\n  return 'hey React!';\n}\n\nfunction App() {\n  return (\n    <div>\n      <h1>{getGreeting()}</h1>\n      <label htmlFor=\"search\">Search: </label>\n      <input id=\"search\" type=\"text\" />\n      <hr />\n      <List />\n    </div>\n  );\n}\nexport default App;\n```\n\nNotice we're importing `List` from a separate file:\n\n```tsx\nconst list = [\n  {\n    title: 'React',\n    url: 'https://reactjs.org/',\n    author: 'Jordan Walke',\n    num_comments: 3,\n    points: 4,\n    objectID: 0,\n  },\n  {\n    title: 'Redux',\n    url: 'https://redux.js.org/',\n    author: 'Dan Abramov, Andrew Clark',\n    num_comments: 2,\n    points: 5,\n    objectID: 1,\n  },\n];\n\nexport function List() {\n  return (\n    <div>\n      {list.map(function (item) {\n        return (\n          <div key={item.objectID}>\n            <span>\n              <a href={item.url}>{item.title}</a>\n            </span>{' '}\n            written by {item.author}\n          </div>\n        );\n      })}{' '}\n    </div>\n  );\n}\n```\n\nWith this example, we can see how components that encapsulate meaningful tasks can work for larger React applications.Larger React applications have component hierarchies (also called component trees). There is usually one uppermost entry point component (e.g. App) that spans a tree of components below it. The App is the parent component of the List, so the List is a child component of the App. In a component tree, the App is the root component, and the components that don’t render any other components are called leaf components (e.g. List). The App can have multiple children, as can the List. If the App has another child component, the additional child component is called a sibling component of the List.\n\n## index.js\n\nWe've been ignoring one important file in our project: `index.js`:\n\n```tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nReactDOM.render(<App />, document.getElementById('root'));\n```\n\nThere is imported library called `react-dom`, in which a ReactDOM.render() function uses an HTML node to replace it with JSX. The process integrates React into HTML. ReactDOM.render() expects two arguments; the first is to render the JSX. It creates an instance of your App component, though it can also pass simple JSX without any component instantiation.\n\nThe second argument specifies where the React application enters your HTML. It expects an element with an id='root', found in the public/index.html file. This is a basic HTML file.\n\n## onChange() handlers\n\nThe App component still has the input field and label, which we haven’t used. In HTML outside of JSX, input fields have an onchange handler. This is what our App component looks like right now:\n\n```tsx\nimport { List } from './List';\n\nfunction getGreeting() {\n  return 'hey React!';\n}\n\nfunction App() {\n  return (\n    <div>\n      <h1>{getGreeting()}</h1>\n      <label htmlFor=\"search\">Search: </label>\n      <input id=\"search\" type=\"text\" />\n      <hr />\n      <List />\n    </div>\n  );\n}\nexport default App;\n```\n\nLet's define a handler function for the change event of the input field. This function can be passed to the `onChange` attribute (JSX named attribute) of the input field:\n\n```tsx\nimport { List } from './List';\n\nfunction getGreeting() {\n  return 'hey React!';\n}\n\nfunction App() {\n  //Handler function:\n  const handleChange = (event: any) => {\n    console.log(event);\n  };\n\n  return (\n    <div>\n      <h1>{getGreeting()}</h1>\n      <label htmlFor=\"search\">Search: </label>\n      <input id=\"search\" type=\"text\" onChange={handleChange} />\n      <hr />\n      <List />\n    </div>\n  );\n}\nexport default App;\n```\n","excerpt":"Intro Typescript is a strict syntactical superset of JavaScript and adds optional static typing to the language. It is designed for the dev…","fields":{"slug":"/Typescript/"},"frontmatter":{"date":"Feb 10, 2023","title":"React and Typescript","tags":["react"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}