{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## functions\n\nAny time you want to perform some sort of repeatable task with JavaScript, you can use a function. Let’s take a look at some of the different syntax options:\n\n### function declarations\n\nA function declaration or function definition starts with the `function` keyword, which is followed by the name of the function, `letsPrint`. The JavaScript statements that are part of the function are defined between the curly braces. Once you’ve declared the function, you’ll invoke or call it to see it execute:\n\n```jsx\nfunction letsPrint() {\n  console.log('Lets print');\n}\nletsPrint();\n```\n\nOnce invoked, you’ll see the message logged to the console.\n\n### function expression\n\nAnother option is to use a function expression. This just involves creating the function as a variable:\n\n```jsx\nconst letsPrint = function () {\n  console.log('Lets print');\n};\nletsPrint();\n```\n\nOne thing to be aware of when deciding between a function declaration and a function expression is that function declarations are hoisted and function expressions are not: meaning you can invoke a function before you write a function declaration. You cannot invoke a function created by a function expression.\n\n### passing arguments\n\nThe `letsPrint` function currently takes in no arguments or parameters. We can pass named parameters to a function by adding them to the parentheses. Let’s start by adding a `firstName` variable:\n\n```tsx\nconst letsPrint = function (firstName: string) {\n  console.log(`Hello ${firstName}`);\n};\n\nletsPrint('Billy');\n```\n\nNow when we call the `letsPrint` function, the `firstName` value sent will be added to the console message. Notice how we need to provide the \"type\" for this variable. We could add to this a bit by creating another argument called message. Now, we won’t hard-code the message. We’ll pass in a dynamic value as a parameter:\n\n```tsx\nconst letsPrint = function (firstName: string, message: string) {\n  console.log(`${message} ${firstName}`);\n};\n\nletsPrint('Billy', 'Hello!');\n```\n\n### function returns\n\nLet's have our function return stuff:\n\n```tsx\nconst letsPrint = function (firstName: string, message: string): string {\n  return `${message} ${firstName}`;\n};\n\nconsole.log(letsPrint('Billy', 'Hello!'));\n```\n\nNotice the return type for this function:\n\n```tsx\n function (...): string\n```\n\n### arrow functions\n\nArrow functions are a useful new feature of ES6. With arrow functions, you can create functions without using the function keyword. You also often do not have to use the return keyword. Let’s consider a function that takes in a firstName and returns a string, turning the person into a soccer fan:\n\n```tsx\nconst makeSoccerFan = (name: string) => `${name} is a soccer fan!`;\n```\n\nWith the arrow, we now have an entire function declaration on one line. The `function` keyword is removed. We also remove return because the arrow points to what should be returned. We can keep this as a one-line function because there is only one statement that needs to be returned. If there are multiple lines, you’ll use curly braces. Also, you can provide the return type from that function: `const myFunc = (.....): string => {`\n\n```tsx\nconst myFunc = (name: string): string => {\n  if (name) {\n    return `${name} is a soccer fan!`;\n  } else {\n    return 'Not a soccer fan!';\n  }\n};\n```\n\n### returning objects\n\nWhat happens if you want to return an object? Consider a function called person that builds an object based on parameters passed in for `firstName` and `lastName`:\n\n```tsx\n// Declared type person\ntype Person = {\n  firstName: string;\n  lastName: string;\n};\n\n// ? means it is optional\nconst getInfo = (firstName?: string, lastName?: string): Person => {\n  if (firstName && lastName) {\n    return {\n      firstName: firstName,\n      lastName: lastName,\n    };\n  } else {\n    return {\n      firstName: 'N/A',\n      lastName: 'N/A',\n    };\n  }\n};\n\nconsole.log(JSON.stringify(getInfo('James', 'Bond')));\n```\n\n## objects and arrays\n\nSince ES2016, JavaScript syntax has supported creative ways of scoping variables within objects and arrays. These creative techniques are widely used among the React community. Let’s take a look at a few of them, including destructuring, object literal enhancement, and the spread operator.\n\n### destructuring objects\n\nDestructuring means picking and choosing only those fields that are of interest to you from an object. Say for example, we're passed an object of type `Person` with a person's `firstName`, `lastName` and age but we only want to display their `firstName` and `lastName`:\n\n```tsx\ntype Person = {\n  firstName: string;\n  lastName: string;\n  age: number;\n};\n\nconst getInfo = ({ firstName, age }: Person) => {\n  console.log(`You sent in: ${firstName}, ${age}`);\n};\n\nconst myPerson: Person = {\n  firstName: 'james',\n  lastName: 'bond',\n  age: 40,\n};\n\ngetInfo(myPerson);\n```\n\nA new notation above:\n\n- Typescript expects us to define the types we're extracting from the object. Thus this line:\n\n```tsx\n({ firstName, age }: Person)\n```\n\nLet’s take this one level farther to reflect a data change. Now, the regularPerson object has a new nested object on the spouse key. So our new `Person` object is now this:\n\n```tsx\ntype Person = {\n  firstName: string;\n  lastName: string;\n  age: number;\n  spouse: {\n    firstName: string;\n    lastName: string;\n  };\n};\n\nconst getInfo = ({ lastName, age, spouse: { firstName } }: Person) => {\n  console.log(\n    `Welcome Mr. ${lastName}, \n    aged ${age} and your wife: \n    ${firstName}`\n  );\n};\n\nconst myPerson: Person = {\n  firstName: 'james',\n  lastName: 'bond',\n  age: 40,\n  spouse: {\n    firstName: 'eva',\n    lastName: 'green',\n  },\n};\n\ngetInfo(myPerson);\n```\n\n### destructuring arrays\n\nValues can also be destructured from arrays. Imagine that we wanted to assign the first value of an array to a variable name:\n\n```tsx\nconst [a] = ['a', 'b', 'c'];\nconsole.log(a); // a\n```\n\nWe can also pass over unnecessary values with list matching using commas. List matching occurs when commas take the place of elements that should be skipped. With the same array, we can access the last value by replacing the first two values with commas:\n\n```tsx\nconst [, , c] = ['a', 'b', 'c'];\nconsole.log(c); // c\n```\n\n### object literal enhancement\n\nThis is the opposite of destructuring: ie reconstructing the object:\n\n```tsx\nconst fName = 'james';\nconst lName = 'bond';\nconst print = function () {\n  console.log(`${this.fName}, ${this.lName}`);\n};\n\nconst actionHero = { fName, lName, print };\nactionHero.print();\n```\n\nNotice we use `this` to access the object keys.\n\nObject literal enhancement allows us to pull global variables into objects and reduces typing by making the function keyword unnecessary.\n\n### spread operator\n\nThe spread operator is three dots `(...)` that perform several different tasks. First, the spread operator allows us to combine the contents of arrays. For example, if we had two arrays, we could make a third array that combines the two arrays into one:\n\n```tsx\nconst one = ['a', 'b', 'c'];\nconst two = ['d', 'e', 'f'];\nconst three = [...one, ...two];\n```\n\nWe can also use the three-dot syntax to collect function arguments as an array. When used in a function, these are called rest parameters. Here, we build a function that takes in `n` number of arguments using the spread operator, then uses those arguments to print some console messages:\n\n```tsx\nfunction directions(...args) {\n  let [start, ...remaining] = args;\n  let [finish, ...stops] = remaining.reverse();\n\n  console.log(`drive through ${args.length} towns`);\n  console.log(`start in ${start}`);\n  console.log(`the destination is ${finish}`);\n  console.log(`stopping ${stops.length} times in between`);\n}\n\ndirections('Truckee', 'Tahoe City', 'Sunnyside', 'Homewood', 'Tahoma');\n```\n\nThe directions function takes in the arguments using the spread operator. The first argument is assigned to the `start` variable. The last argument is assigned to a `finish` variable using `Array.reverse`. We then use the length of the arguments array to display how many towns we’re going through. The number of stops is the length of the arguments array minus the finish stop.\n\nThe spread operator can also be used for objects:\n\n```tsx\nconst morning = {\n  breakfast: 'oatmeal',\n  lunch: 'peanut butter and jelly',\n};\nconst dinner = 'mac and cheese';\nconst backpackingMeals = { ...morning, dinner };\nconsole.log(backpackingMeals);\n// {\n// breakfast: \"oatmeal\",\n// lunch: \"peanut butter and jelly\",\n// dinner: \"mac and cheese\"\n// }\n```\n\n## asynchronous execution\n\nSo far, we've seen synchronous execution. Let's see how we can make async calls:\n\n### fetch and promise\n\n```tsx\nimport fetch from 'cross-fetch';\nconsole.log(fetch('https://api.randomuser.me/?nat=US&results=1'));\n```\n\nWe're fetching a response from an API using the `fetch` library.\n\nRunning the above returns: `Promise { <pending> }`. What does that mean?! The promise is an object that represents whether the async operation is pending, has been completed, or has failed. The pending promise represents a state before the data has been fetched. We need to chain on a function called `.then()`. This function will take in a callback function that will run if the previous operation was successful. The `then` method will invoke the callback function once the promise has resolved. In other words, fetch some data, \"then\" convert response to JSON:\n\n```tsx\nimport fetch from 'cross-fetch';\n\nfetch('//api.github.com/users/lquixada')\n  .then((res) => {\n    if (res.status >= 400) {\n      throw new Error('Bad response from server');\n    }\n    return res.json();\n  })\n  .then((user) => {\n    console.log(user);\n  })\n  .catch((err) => {\n    console.error(err);\n  });\n```\n\nYou see this gets ugly! Too many `.then()` calls.\n\n### async and await\n\nUsing `async` and `await` is preferred because it looks more familiar, like code that’s found in a synchronous function. Instead of waiting for the results of a promise to resolve and handling it with a chain of `then` functions, `async` functions can be told to wait for the promise to resolve before further executing any code found in the function.\nLet’s make another API request but wrap the functionality with an async function:\n\n```tsx\n// async function\nconst getInfo = async () => {\n  try {\n    //await the result\n    const res = await fetch('//api.github.com/users/lquixada');\n\n    if (res.status >= 400) {\n      throw new Error('Bad response from server');\n    }\n\n    const user = await res.json();\n\n    console.log(user);\n  } catch (err) {\n    console.error(err);\n  }\n};\n\ngetInfo();\n```\n\nNotice that the getFakePerson function is declared using the async keyword. This makes it an asynchronous function that can wait for promises to resolve before executing the code any further. The `await` keyword is used before promise calls. This tells the function to wait for the promise to resolve.\n\n## imperative vs declarative\n\nFunctional programming is a part of a larger programming paradigm: `declarative programming`. Declarative programming is a style of programming where applications are structured in a way that prioritizes **describing what should happen** over defining how it should happen.\n\nContrast that with imperative programming which is a style of programming that’s only concerned with how to achieve results with code. Let's start with the imperative approach (one you're comfortable with!):\n\nFirst, let’s examine an imperative approach to this task. Ane example that replaces white spaces with a hyphen:\n\n```tsx\nconst string = 'You are great';\nconst urlFriendly = '';\nfor (var i = 0; i < string.length; i++) {\n  if (string[i] === ' ') {\n    urlFriendly += '-';\n  } else {\n    urlFriendly += string[i];\n  }\n}\nconsole.log(urlFriendly); // \"You-are-great\"\n```\n\nHere's declarative approach for the same:\n\n```tsx\nconst string = 'You are great';\nconst urlFriendly = string.replace(/ /g, '-');\nconsole.log(urlFriendly);\n```\n\nUsing `string.replace` is a way of describing what’s supposed to happen: spaces in the string should be replaced. The details of how spaces are dealt with are abstracted away inside the replace function. In a declarative program, the syntax itself describes what should happen, and the details of how things happen are abstracted away. Declarative programs are easy to reason about because the code itself describes what is happening.\n\nNow, let’s consider the task of building a document object model, or `DOM`. An imperative approach would be concerned with how the `DOM` is constructed:\n\n```tsx\nconst target = document.getElementById('target');\nconst wrapper = document.createElement('div');\nconst headline = document.createElement('h1');\nwrapper.id = 'welcome';\nheadline.innerText = 'Hello World';\nwrapper.appendChild(headline);\ntarget.appendChild(wrapper);\n```\n\nThis code is concerned with creating elements, setting elements, and adding them to the document. It would be very hard to make changes, add features, or scale 10,000 lines of code where the `DOM` is constructed imperatively.\nNow let’s take a look at how we can construct a DOM declaratively using a React component:\n\n```tsx\nconst { render } = ReactDOM;\nconst Welcome = () => (\n  <div id=\"welcome\">\n    <h1>Hello World</h1>\n  </div>\n);\nrender(<Welcome />, document.getElementById('target'));\n```\n\nReact is declarative. Here, the `Welcome` component describes the `DOM` that should be rendered. The render function uses the instructions declared in the component to build the `DOM`, abstracting away the details of how the `DOM` is to be rendered. We can clearly see that we want to render our `Welcome` component into the element with the ID of `target`.\n\n## React\n\nReact is a library that’s designed to update the browser DOM for us. We no longer have to be concerned with the complexities associated with building high-performing SPAs because React can do that for us. With React, we do not interact with the DOM API directly. Instead, we provide instructions for what we want React to build, and React will take care of rendering and reconciling the elements we’ve instructed it to create. React elements are the instructions for how the browser DOM should be created.\n\n### react DOM\n\nOnce we’ve created a React element, we’ll want to see it in the browser. ReactDOM contains the tools necessary to render React elements in the browser. `ReactDOM` is where we’ll find the render method.\nWe can render a React element, including its children, to the DOM with `ReactDOM.render`. The element we want to render is passed as the first argument, and the second argument is the target node, where we should render the element.\n\nThe `dish` element below has 3 arguments:\n\n```tsx\nconst dish = React.createElement('h1', 'id-0', 'Baked Salmon');\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\nroot.render([dish, dessert]);\n```\n\n- The first argument, `h1` defines the type of element we want to create. In this case, we want to create an h1 element.\n\n- The second argument, `id-0`, represents the element’s properties. This h1 currently has an id of `id-0`.\n\n- The third argument,`Baked Salmon`, represents the element’s children: ie any nodes that are inserted between the opening and closing tag (in this case, just some text).\n\nWe build this div inside the body tag:\n\n```tsx\n<body>\n  <div id=\"root\">\n    <h1 id=\"id-0\">Baked Salmon</h1>{' '}\n  </div>\n</body>\n```\n\nYou can also render multiple elements:\n\n```tsx\nconst dish = React.createElement('h1', null, 'Baked Salmon');\nconst dessert = React.createElement('h2', null, 'Coconut Cream Pie');\n\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\nroot.render([dish, dessert]);\n```\n\n## react rendering\n\nLet’s consider an unordered list that contains ingredients:\n\n```tsx\n<ul>\n  <li>2 lb salmon</li>\n  <li>5 sprigs fresh rosemary</li>\n  <li>2 tablespoons olive oil</li>\n  <li>2 small lemons</li>\n  <li>1 teaspoon kosher salt</li> <li>4 cloves of chopped garlic</li>\n</ul>\n```\n\nHere, the unordered list, `ul` is the root element, and it has six children (`li`). We can represent this `ul` and its children with `React.createElement`:\n\n```tsx\nconst myElement = React.createElement(\n  'ul',\n  null,\n  React.createElement('li', null, '2 lb salmon'),\n  React.createElement('li', null, '5 sprigs fresh rosemary'),\n  React.createElement('li', null, '2 tablespoons olive oil'),\n  React.createElement('li', null, '2 small lemons'),\n  React.createElement('li', null, '1 teaspoon kosher salt'),\n  React.createElement('li', null, '4 cloves of chopped garlic')\n);\n\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\nroot.render(myElement);\n```\n\nNotice that `li` tags are now the children of `ul`.\n\nIf we were to inspect the resulting React element, we would see each list item represented by a React element and added to an array called `props.children`. If you console log this element, you'll see this:\n\n```txt\n{\n  \"type\": \"ul\",\n  \"props\": {\n  \"children\": [\n  { \"type\": \"li\", \"props\": { \"children\": \"2 lb salmon\" } ... },\n  { \"type\": \"li\", \"props\": { \"children\": \"5 sprigs fresh rosemary\"} ... },\n  { \"type\": \"li\", \"props\": { \"children\": \"2 tablespoons olive oil\" } ... },\n  { \"type\": \"li\", \"props\": { \"children\": \"2 small lemons\"} ... },\n  { \"type\": \"li\", \"props\": { \"children\": \"1 teaspoon kosher salt\"} ... },\n  { \"type\": \"li\", \"props\": { \"children\": \"4 cloves of chopped garlic\"} ... }\n  ]\n}\n```\n\nThe major advantage of using React is its ability to separate data from UI elements. Since React is just JavaScript, we can add JavaScript logic to help us build the React component tree. For example, ingredients can be stored in an array, and we can map that array to the React elements.\nLet’s go back and think about the unordered list for a moment:\n\n```tsx\nReact.createElement(\n  'ul',\n  null,\n  React.createElement('li', null, '2 lb salmon'),\n  React.createElement('li', null, '5 sprigs fresh rosemary'),\n  React.createElement('li', null, '2 tablespoons olive oil'),\n  React.createElement('li', null, '2 small lemons'),\n  React.createElement('li', null, '1 teaspoon kosher salt'),\n  React.createElement('li', null, '4 cloves of chopped garlic')\n);\n```\n\nThe data used in list of ingredients above can easily be represented using a JavaScript array:\n\n```tsx\nconst items = [\n  '2 lb salmon',\n  '5 sprigs fresh rosemary',\n  '2 tablespoons olive oil',\n  '2 small lemons',\n  '1 teaspoon kosher salt',\n  '4 cloves of chopped garlic',\n];\n```\n\nWe want to use this data to generate the correct number of list items without having to hard-code each one. We can map over the array and create list items for as many ingredients as there are:\n\n```tsx\nconst items = [\n  '2 lb salmon',\n  '5 sprigs fresh rosemary',\n  '2 tablespoons olive oil',\n  '2 small lemons',\n  '1 teaspoon kosher salt',\n  '4 cloves of chopped garlic',\n];\n\nconst finalList = React.createElement(\n  'ul',\n  null,\n  items.map((item) => React.createElement('li', null, item))\n);\n\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\nroot.render(finalList);\n```\n\nThis syntax creates a React element for each ingredient in the array. Each string is displayed in the list item’s children as text. The value for each ingredient is displayed as the list item. When running this code, you’ll see a console warning like:\n\n```tsx\nreact.development.js:207 Warning: Each child in a list should have a unique \"key\" prop.\nCheck the top-level render call using <ul>. See https://reactjs.org/link/warning-keys for more information.\nat li\n```\n\nWhen we build a list of child elements by iterating through an array, React recommends each of those elements to have a key property. The `key` property is used by React to help it update the `DOM` efficiently. You can make this warning go away by adding a unique key property to each of the list item elements. You can use the array index for each ingredient as that unique value:\n\n```tsx\nconst items = [\n  '2 lb salmon',\n  '5 sprigs fresh rosemary',\n  '2 tablespoons olive oil',\n  '2 small lemons',\n  '1 teaspoon kosher salt',\n  '4 cloves of chopped garlic',\n];\n\nconst finalList = React.createElement(\n  'ul',\n  null,\n  items.map((item) => React.createElement('li', { key: i }, item))\n);\n\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\nroot.render(finalList);\n```\n\n`i` is auto incremented as we loop through the array thus providing a unique key for each `li` item.\n\n## jsx\n\nIn the previous section we used `React.createElement()` quite a lot! It is not a recommended approach. The only reason we talked about it was to understand what's going on behind the scenes. Instead, we should be using `jsx` syntax:\n\n```tsx\nconst element = <h1>Hello, world!</h1>;\n```\n\nIt is called `JSX`, and it is a syntax extension to JavaScript. We use it with React to describe what the UI should look like. It comes with the full power of JavaScript. React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.\n\nInstead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called [components](#components) that contain both.\n\nReact doesn’t require using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.\n\nConverting the previous example to `JSX`, you get this:\n\n```tsx\nconst items = [\n  '2 lb salmon',\n  '5 sprigs fresh rosemary',\n  '2 tablespoons olive oil',\n  '2 small lemons',\n  '1 teaspoon kosher salt',\n  '4 cloves of chopped garlic',\n];\n//old\n/**const finalList = React.createElement(\n  'ul',\n  null,\n  items.map((item) => React.createElement('li', { key: i }, item))\n);*/\n\nconst listItems = items.map((item, i) => <li key={i}>{item}</li>);\nconst finalList = <ul>{listItems}</ul>;\n\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\nroot.render(finalList);\n```\n\nWe've created a new `listItems` variable:\n\n```tsx\nconst listItems = items.map((item, i) => <li key={i}>{item}</li>);\n```\n\nthat maps each array item to a `li` tag (with a unique key of-course!);\n\nNext, we then created our final variable that will be rendered called `finalList` that creates an `ul` out of the `li`:\n\n```tsx\nconst finalList = <ul>{listItems}</ul>;\n```\n\nNotice how `JSX` allows us to add HTML to JavaScript!\n\n## components\n\nWhen considering a user interface you want to build with React, we break down elements into reusable pieces. For example, the recipes in figure below have a title, ingredients list, and instructions. All are part of a larger recipe or app component. These reusable pieces are called `components` We could create a component for each of the highlighted parts: ingredients, instructions, and so on:\n\n![](recipe-1.png)\n\nThis is a scalable solution! If we want to display one recipe or 10,000, our component structure will support this. The diagram above is labelled with the components that can be used:\n\n- `App`: the main component that will hold all recipes\n- `1`: The recipe component called `Recipe`.\n- `2`: A container that will display the title of this recipe called `Title`\n- `3`: Container showing ingredients of the recipe called `Ingredients`\n- `4`: Container showing instructions of the recipe called `Instructions`\n\nCheck out [this](https://github.com/iqbalyarkhan/recipes/commit/d72498530bf1ccae988f6d9b737e46b42abf3e27) commit where I cleaned up a new react project and added placeholders for components described above.\n\n🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧🛑🚧\n\nLet's create our first component:\n\n```tsx\nimport React from 'react';\nimport './App.css';\n\nfunction Button() {\n  return <button>alert('You clicked me!')</button>;\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <p>Learn React</p>\n      <Button />\n    </div>\n  );\n}\n\nexport default App;\n```\n\nA few things to note above:\n\n- We have default component that's exported from this file called `App`\n- We have another component called `Button`.\n\nNotice how we use `Button` inside of `App`:\n\n```tsx\n<Button />\n```\n\nAlso notice that the name of this new component needs to start with an upper case. React components are regular JavaScript functions, but their names must start with a capital letter or they won’t work!\n\n## Event Handlers\n\nYou can respond to events by declaring event handler functions inside your components:\n\n```tsx\nfunction MyButton() {\n  function handleClick() {\n    alert('You clicked me!');\n  }\n\n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\nNotice how `onClick={handleClick}` has no parentheses at the end! Do not call the event handler function: you only need to pass it down. React will call your event handler when the user clicks the button.\n\n## State\n\nOften, you’ll want your component to “remember” some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add state to your component.\n\nFirst, we need to import `useState` from `react`:\n\n```tsx\nimport React from 'react';\nimport { useState } from 'react';\nimport './App.css';\n```\n\nNow you can declare a state variable inside your component:\n\n```tsx\nconst [count, setCount] = useState(0);\n```\n\nYou will get two things from `useState`: the current state (`count`), and the function that lets you update it (`setCount`). You can give them any names, but the convention is to call them like `[something, setSomething]`.\n\nThe first time the button is displayed, count will be 0 because you passed 0 to `useState()`. When you want to change state, call `setCount()` and pass the new value to it. Clicking this button will increment the counter:\n\n```tsx\nimport React from 'react';\nimport { useState } from 'react';\nimport './App.css';\n\nfunction Button() {\n  const [count, setCount] = useState(0);\n  function handleClick() {\n    setCount(count + 1);\n  }\n  return <button onClick={handleClick}>'You clicked me: {count} times </button>;\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <p>Learn React</p>\n      <Button />\n    </div>\n  );\n}\n\nexport default App;\n```\n\nLet's look at the update `Button` component:\n\n```tsx\nfunction Button() {\n  const [count, setCount] = useState(0);\n  function handleClick() {\n    setCount(count + 1);\n  }\n  return <button onClick={handleClick}>'You clicked me: {count} times </button>;\n}\n```\n\n- notice the `const` keyword while using the state\n- notice there's another function called `handleClick` inside of `Button`.\n- notice that we don't do this: `count = count + 1`, we just tell what to do with `count` and let `setCount` do the rest: `setCount(count + 1)`.\n\nYou can use the `Button` component as many times as you want and each `Button` will come with its own counter:\n\n```tsx\nimport { useState } from 'react';\nimport React from 'react';\nimport './App.css';\n\nfunction Button() {\n  const [count, setCount] = useState(0);\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return <button onClick={handleClick}> You clicked me {count} times! </button>;\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <p>Learn React</p>\n      <Button />\n      <Button />\n    </div>\n  );\n}\n\nexport default App;\n```\n\nEach button “remembers” its own count state and doesn’t affect other buttons.\n\n## Hooks\n\nFunctions starting with `use` are called `Hooks`. `useState` is a built-in Hook provided by React. You can find other built-in Hooks in the [React API reference](https://beta.reactjs.org/reference/react). You can also write your own Hooks by combining the existing ones.\n\nHooks are more restrictive than regular functions. You can only call Hooks at the top level of your components (or other Hooks). If you want to use useState in a condition or a loop, extract a new component and put it there.\n\nIn the previous example, each `Button` had its own independent count, and when each button was clicked, only the count for the button clicked changed:\n\n![](sharing_data_child.webp)\n\nHowever, often you’ll need components to share data and always update together.\n\nTo make both `Button` components display the same count and update together, you need to move the state from the individual buttons “upwards” to the closest component containing all of them. In our example, this closest component is `App`:\n\n![](sharing_data_parent_clicked.webp)\n\nNow when you click either button, the count in `App` will change, which will change both of the counts in `Button`. Here’s how you can express this in code.\n\n1. Here is what we had:\n\n```tsx\nimport { useState } from 'react';\nimport React from 'react';\nimport './App.css';\n\nfunction Button() {\n  const [count, setCount] = useState(0);\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return <button onClick={handleClick}> You clicked me {count} times! </button>;\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <p>Learn React</p>\n      <Button />\n      <Button />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n2. We need to move the state \"up\" to `App`:\n\n```tsx\nfunction Button() {\n  return <button onClick={handleClick}> You clicked me {count} times! </button>;\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <div className=\"App\">\n      <p>Learn React</p>\n      <Button />\n      <Button />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n3. Next, we need to pass the `count` and `setCount` state variables to the `Button` component. This is done just like how you'd pass a variable to a component. You also need to change the signature for `Button` component to accept `count` and `setCount`. The information you pass down like this is called `props`. `App` component contains the `count` state and the `handleClick` event handler, and passes both of them down as props to each of the buttons.\n\n```tsx\nfunction Button({ count, onClick }: any) {\n  return <button onClick={onClick}> You clicked me {count} times! </button>;\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <div className=\"App\">\n      <p>Learn React</p>\n      <Button count={count} onClick={handleClick} />\n      <Button count={count} onClick={handleClick} />\n    </div>\n  );\n}\n\nexport default App;\n```\n\nLet's look at the `Button` component:\n\n```tsx\nfunction Button({ count, onClick }: any) {\n  return <button onClick={onClick}> You clicked me {count} times! </button>;\n}\n```\n\n- it is accepting variables: `{count, onClick}` of type `any`\n- the button onClick calls the function passed in which is also called `onClick`.\n- value of `count` is displayed as text in the button\n\nFrom `App`:\n\n```tsx\nfunction App() {\n  const [count, setCount] = useState(0);\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <div className=\"App\">\n      <p>Learn React</p>\n      <Button count={count} onClick={handleClick} />\n      <Button count={count} onClick={handleClick} />\n    </div>\n  );\n}\n```\n\n- We initialize the state like before using `useState` and declare a `handleClick` function that updates the state\n- We call `Button` with the state value and state updater function\n\nWhen you click the button, the `onClick` handler fires. Each button’s `onClick` prop was set to the `handleClick` function inside `App`, so the code inside of it runs. That code calls `setCount(count + 1)`, incrementing the `count` state variable. The new count value is passed as a prop to each button, so they all show the new value.\n\nThis is called “lifting state up”. By moving state up, we’ve shared it between components.\n\nWith the above in place, your buttons will both reflect the updated value as you click on any button. I made mine a little fun where we start off from 10 and each click reduces the number. While the number > 0, we're healthy and at 0, we alert happy new year! `App` component stays the same:\n\n```tsx\nfunction Button({ count, onClick }: any) {\n  return (\n    <button onClick={onClick}>\n      Remaining: {count > 0 ? count : '0'} {count > 0 ? 'old year' : 'happy new year!'}\n    </button>\n  );\n}\n\nfunction App() {\n  const [count, setCount] = useState(10);\n\n  function handleClick() {\n    setCount(count - 1);\n  }\n\n  return (\n    <div className=\"App\">\n      <p>Learn React</p>\n      <Button count={count} onClick={handleClick} />\n      <Button count={count} onClick={handleClick} />\n    </div>\n  );\n}\n```\n","excerpt":"functions Any time you want to perform some sort of repeatable task with JavaScript, you can use a function. Let’s take a look at some of t…","fields":{"slug":"/React/"},"frontmatter":{"date":"Feb 23, 2023","title":"React","tags":["react"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Intro\n\nWe'll look at a few different \"types\" of networks present.\n\nThere's local networking that deals with how data moves between devices on your local network.\n\nThere's routing: how data moves from your network to another network (AWS, Netflix etc)\n\nWe'll look at how data is actually transmitted from one point to another (segmenting, ports and sessions).\n\n## OSI 7-Layer Model\n\nTo understand networks, we'll go through a conceptual model that is a stack of all the components that make networking possible. This model is called the OSI 7-Layer model:\n\n![OSI-Model](OSI-7-layers.jpeg)\n\nEach \"device\" capable of communicating with networks (ie connected to the internet!) will have a networking stack. Layers 1, 2 and 3 are called the media layers and the remaining are called host layers. Media layer is responsible for helping data move from point A to point B. Hosts layers are responsible for determining how data is chopped up and re-assembled.\n\nConceptually, data is sent from layer 7 of once machine (for example your browser), flows all the way down to layer 1 and back up to layer 7 on another machine (youtube server you're watching that video from!).\n\n## Layer 1 - Physical\n\nThis layer includes the physical equipment involved in the data transfer, such as the cables and switches. This is also the layer where the data gets converted into a bit stream, which is a string of 1s and 0s. You can think of this as a setup where 2 machines are connected via a cable or WIFI that communicate directly with each other.\n\n![layer-1](layer_1.png)\n\nAt this layer, the two connected machines agree on a standard where a certain voltage means Binary 1 and another means Binary 0. This allows the two connected machines to transmit data between each other.\n\n### Hub\n\nWhat if we want to add more machines to our system? Not just 2? We can use a layer 1 device called a 4 port hub (to connect 4 machines) to connect 4 machines with each other. The job of a hub is simple: anything received by the hub on any port is transmitted on every other port (including errors and collisions!). See issues here?\n\n- All data is processed by all devices (you can't direct data to a specific port/machine)\n- No way to prevent multiple devices from transmitting at once. So if 2 devices transmit at once, it will cause a collision. Also layer 1 cannot detect when a collision occurs. It lacks any intelligence.\n- No way to control which devices can transmit data\n\n## Layer 2 - Data Link Layer\n\nWe saw the limitations of layer 1 (no device to device communication, no collision avoidance, no transmission control) due to which we need layer 2. Layer 2 requires a functioning layer 1. Assume that for our example, layer 1 is running on ethernet.\n\n![layer-2](layer_2.png)\n\nLayer 2 sends information over a network using a concept called **frames**.\n\nDevices also have a unique hardware address called a **MAC address** for every device on a network. Addresses look like this: `3e:22:fb:b9:5b:75`. MAC address is attached to a specific piece of hardware.\n\nA MAC address consists of 2 parts, an OUI (organizationally unique identifier) which distinguishes one company from another. The other part is network interface controller (or NIC). This means MAC + NIC should result in a globally unique MAC address.\n\nKeep in mind that layer 1 doesn't understand frames or mac addresses. All it does is that it receives the data from layer 2, transmits it across to another device listening on layer 1, and then the data is moved on up to layer 2 of the receiver.\n\n### Frame\n\nA frame is composed of many parts:\n\n![frame](frame.png)\n\nThe first part is the preamble and start frame delimiter (SFD). It allows devices to know that this is the start of the frame. Preamble is 56 bits or 7 bytes (8 bits per byte) and SFD is 8 bits or 1 byte. A layer 2 receiver needs to know where the start of a frame is to make sense of the information contained within it.\n\nNext is the destination and source mac addresses. If you want to send to all devices on the local network, you put all Fs for destination aka broadcast. The source MAC address allows the sender to receive replies.\n\nNext is ether type (or type) that helps determine what layer 3 protocol is putting its data inside the frame. That's because layer 3 builds on top of layer 2 and uses layer 2 for device to device communication on a local network. When the receiver receives data, it needs to know the layer 3 protocol that put data into that frame.\n\nDestination MAC address, source MAC address and type are referred to as MAC header\n\nAfter the header, we have the payload which can range from 46 to 1500 bytes. This contains the data that the frame is sending which is generally provided by layer 3.\n\nAt the end there's the frame check sequence that is used to identify any errors in the frame. It allows the destination to check whether any corruption has occurred or not.\n\n### Layer 2 Complete Flow\n\nLet's checkout a complete flow:\n\n![recap](recap.png)[Credit: learn.cantrill.io](learn.cantrill.io)\n\nSay the machine on the left, let's call it L, needs to send data to machine on the right, R. L knows MAC address of R. L interacts with layer 2 software saying that it needs to send data to R via an ethernet. Data to be transmitted is stored in the payload part of the frame. Layer 2 can communicate with layer 1 the networking stack and it can look for the signs of a \"carrier\" signal. Layer 2 is looking to \"sense\" a carrier. A carrier signal means that there's already data in the signal and we don't want to corrupt existing data. This is the job of CSMA (carrier sense multiple access). If a carrier isn't detected, the frame is passed on to layer 1. This comes in handy in the scenario where R layer 2 is also trying to send data while L is transmitting. Detection of carrier signal will prompt R to wait until it gets the all clear.\n\nWhat if there was no carrier detected and both layer 2s transmitted data? Layer 2 contains collision detection. This is the job of collision detection where a jam signal is sent out by all devices that detected a collision. Then a random backoff occurs. This is random as it will allow a device at random to start transmitting again.\n\nLayer 1 doesn't understand what the frame is. It just receives the data from layer 2 and transmits it across. R side receives the data and passes it up to its layer 2. R layer 2 reviews destination mac address of the frame and passes it to R machine.\n\n![recap2](recap-2.png)[Credit: learn.cantrill.io](learn.cantrill.io)\n\nIn this approach we've encapsulated data into frames for transmission!\n\n### Switch\n\nNow remember our example from earlier in layer 1 where we had a hub that connected 4 devices? To do the same at layer 2, we use something called a switch! Hub was a layer 1 device and had layer 1 limitations. Switch is a layer 2 device and holds a great advantage over hubs! Let's say we have a machine at 12 O'clock (A) transmitting to machine at 3 O'Clock (B):\n\nBecause our devices are layer 2, each machine has its own mac address. Since a switch is a layer 2 device, it understands layer 2 mechanisms. Since each device on our network has a unique address, we need to keep track of those addresses. To do so, our switch keeps track of these addresses using something called a **mac address table (MAT)**. As switches receive traffic, they populate the MAT.\n\n![switch](switch-2.png)[Credit: learn.cantrill.io](learn.cantrill.io)\n\nNow let's assume that the MAT is populated and A needs to send data to B. It creates the frame and sends it over to the switch via layer 1. Switch sees the frame arrive at the port to which A is connected to. At this point 1 of 2 things will happen:\n\n- If switch didn't know which port the destination MAC address was on, it will forward this frame to all the ports\n- If switch does know which port the destination MAC address is attached to, it will use that one port to forward the frame\n\nSwitches also do not forward collisions therefore reducing the scope of collisions.\n\n![switch-2](switch-3.png)[Credit: learn.cantrill.io](learn.cantrill.io)\n\n## Binary to Decimal\n\nAt times, we'll have to convert IPv4 addresses from decimal to binary. Here's an IPv4 address: `133.33.33.7`. Each value between the dot is 8 bytes which means this is a 32 bit number. Converting this to binary should be easy! We'll use this table to perform our conversion:\n\n![decimal-to-binary](decimal-binary.png)\n\nLet's start from left to right in both the table and with our IPv4 address. So:\n\n- pick 133 and keep going down the table until you find the largest value that's <= 133\n- look at the table above and notice that 128 < 133, so put a 1 in that position. Now we're left with 5 (133 - 28 = 5)\n- Keep moving down the table until you get to largest number that's <= 5 which is 4. Put a 1 in that position. Now we're left with 1 (5 - 4 = 1)\n- Keep going down and put a 1 at position 8.\n- All untouched positions will have a 0:\n\n`10000101`\n\n## Layer 3\n\nLayer 3 requires layers 2 and 1. Layer 3's job is to get data from one location (for example a server hosting a video) to another (your laptop). So far we've talked about how machines on the same local area network talk to each other. But what about communication between 2 LANs? Layer 3 is the common protocol that helps communication between multiple layer 2 networks.\n\nLayer 3 adds the internet protocol, or IP, to layer 2. This allows for cross-network (across LANs) IP addressing and routing to move data without direct point-to-point (P2P) links. IP \"packets\" are moved step by step from source to destination via intermediate networks while encapsulated in different frames along the way.\n\nDevices that move packets across networks are called routers. They remove frame encapsulation and add new frame encapsulation at every hop.\n\n### Packets\n\nSimilar to frames, packets encapsulate data that needs to be moved from one machine to another. The difference with packets is that unlike frames, packets can be transferred from destinations not in the same LAN as the source. Packets are placed inside frames where a frame is specific to the local network through which our packet is moving. The frame changes every time packet moves to a new network. The packet remains unchanged (in most cases).\n\n### Packet Structure\n\nPackets can be of 2 types: v4 or v6. For our use-case, we'll focus on a few important fields within a packet (anything not in blue):\n\n![v4-v6](v4-v6.png)\n\n- Source/Destination IP address\n- Time to live or Hop limit (number of hops before the packet \"expires\"). This is to prevent infinite forwarding\n- Protocol: Layer 4 protocol used (TCP, UDP, ICMP)\n\nNotice for v6, we have a larger address field.\n","excerpt":"Intro We'll look at a few different \"types\" of networks present. There's local networking that deals with how data moves between devices on…","fields":{"slug":"/Networking/"},"frontmatter":{"date":"Feb 19, 2023","title":"Networking Foundations","tags":["Networking"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Intro\n\nEncryption is the method by which information is converted into secret code that hides the information's true meaning. The science of encrypting and decrypting information is called cryptography.\n\n**Unencrypted** data is **plaintext** (could be text, image, document etc)\n\n**Encrypted** data is **ciphertext** (could be text, image, document etc)\n\n**Encryption key** is similar to a password that is used to generate ciphertext\n\n**Algorithm** takes plaintext and an encryption key to create ciphertext. There are many algorithms that do this: AES, Blowfish, RC4 etc\n\nThe formulas used to encode and decode messages are called encryption algorithms, or ciphers. Process of encryption takes plaintext and a key and uses an algorithm to generate ciphertext. Decryption is the process of taking ciphertext and key to create plaintext.\n\n## Encryption at rest\n\nEncryption at rest is a type of encryption designed to prevent theft of sensitive data. This type of encryption is usually applied on hard-drives, cloud environment hardware etc. A \"secret\" is used to encrypt and decrypt the data. The secret is not to be shared with others. Only those that have knowledge of the secret would be able to decrypt the data\n\nUsually with this type of encryption, only a single party is involved that is responsible for encryption and decryption of the data.\n\n## Encryption in transit\n\nIn this type of encryption, data is encrypted as it is transferred between two parties. Party A (you) encrypt the data and send it to party B (your bank). Party B decrypts the data, performs some action, encrypts new data and returns this new data back to party A.\n\nThis type of encryption involves multiple systems or users.\n\n## Symmetric key encryption\n\n![symmetric](symmetric.jpeg)\n\nSay you have sender and receiver who want to exchange ciphertext with each other. They do the following:\n\n- Agree on an algorithm (AES-256 for example)\n- The sender takes plaintext and a symmetric encryption key and feeds it to AES-256 algorithm\n- Algorithm outputs ciphertext\n- Ciphertext is then transferred over to receiver\n- **The receiver needs to have the same key that was used to encrypt the data!**\n\nHow do we transfer the key that was used to encrypt the data?! This is why symmetric encryption is not ideal for encryption in transit. It is better suited for encrypting local data (hard drives, cloud servers etc). But just to complete the example above:\n\n- Receiver decrypts the ciphertext using the encryption key that was used\n\n## Asymmetric key encryption\n\n![asymmetric](asymmetric.webp)\n\nSay you have sender and receiver who want to exchange ciphertext with each other. They do the following:\n\n- Agree on an algorithm (public-key encryption or digital signatures for example)\n- The sender takes plaintext and creates asymmetric keys (notice plural!) for that algorithm. Asymmetric encryption uses 2 keys: a public key and a private key.\n- The public key is used to generate the ciphertext and this ciphertext is only decryptable by the private key! Public key cannot decrypt data that it was used to encrypt. The public key is made publicly available\n- The sender downloads the public key made available by the receiver. The sender then uses the public key to create ciphertext and transmit it to the receiver\n- The receiver already has the private key. Receiver provides the private key and cipher text to the algorithm and is able to read plaintext data.\n\nNotice in the flow above, no sensitive key exchange is required! Public key can be used by anyone to create ciphertext and send it to the receiver. But the receiver is the only person who has the private key and is able to decrypt the data.\n\nThis type of encryption is used when two or more parties are involved. This used by SSL or TLS encryption (browser communication) and SSH for example.\n\nAsymmetric encryption is computationally expensive so usually asymmetric encryption is used to exchange symmetric keys and then use symmetric encryption for further communication!\n\n## Signing\n\nSay the receiver has received the message and wants to respond with that confirmation via asymmetric encryption.One option is that the receiver can send an OK message. However, in asymmetric encryption, anyone can get sender's public key and use that to respond with an OK. Receiver can't be sure that the OK was from the intended receiver. This is where signing comes in.\n\nWith signing, the receiver can use their private key and sign that message. The receiver gets the message and it can then use the sender's public key to prove whether that message was signed by the intended receiver.\n\n![signing](signing.png)[Credit: learn.cantrill.io]\n\nKey signing is used for ID verification.\n","excerpt":"Intro Encryption is the method by which information is converted into secret code that hides the information's true meaning. The science of…","fields":{"slug":"/Encryption/"},"frontmatter":{"date":"Feb 16, 2023","title":"Encryption","tags":["Encryption","Security"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Intro\n\nWhen you sign up for AWS using your email and password, you're assigned a user called the `root` user. This user has unrestricted access to all resources in that account. If this account gets hacked, this account will be at the mercy of the hacker. The root user cannot be restricted. We want to be able to provide access to others that isn't without restrictions: for example, the BI department might need access to AWS QuickSight but not to AWS S3. This process of providing only required access is called Least Privileged Access. This is where IAM comes handy!\n\n## [IAM](https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html)\n\nIAM:\n\n- Is a global service that is globally resilient service. All data is replicated across all regions\n- Manages identities since it is an identity provider or **IDP**\n- Provides **authentication** (who is signed in?): I am who I say I am!\n- Provides **authorization** (who has permissions?) for AWS services. A service evaluates if an AWS request is allowed or denied. Access is denied by default and is allowed only when a policy explicitly grants access.\n\n## IAM Entities\n\n![users-groups-roles](users_groups_roles.png)\n\nUsing IAM, you can create IAM Users, IAM Groups and IAM Roles. Each have their own specific use-case:\n\n### IAM Users\n\nThe \"identity\" aspect of AWS Identity and Access Management (IAM) helps you with the question \"Who is that user?\", often referred to as authentication. Users are identities which represent humans that need access to your account. IAM users are not separate accounts; they are users within your account. Each user can have its own password for access to the AWS Management Console.\n\nIAM users are granted long term credentials to your AWS resources. As a best practice, you should require your human users to use temporary credentials when accessing AWS. You can use an identity provider for your human users to provide federated access to AWS accounts by assuming roles, which provide temporary credentials.\n\n### IAM Groups\n\nGroups are simply collections of related users. This is useful when you need to provide access to users who have similar roles in an org. For example, QuickSight access for all BAs in your BI group.\n\n### IAM Roles\n\nRoles help us provide permissions to:\n\n- AWS services to perform actions on our behalf. For example lambda in our account writing to S3 bucket in our account.\n- External services to our account. For example lambda in another account writing to S3 bucket in our account.\n\n### Best Practice\n\nAs a [best practice](https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html), require human users to use federation with an identity provider to access AWS using temporary credentials. An additional best practice recommendation is to require workloads to use temporary credentials with IAM roles to access AWS. IAM users are to be used only in very limited scenarios where an IAM role cannot be assumed.\n\n## IAM Policies\n\nHow does IAM actually \"attach\" these permissions to the entities listed above? That's where IAM policies come into picture. Policies are JSON documents that define deny or allow rights. On its own, a policy document does nothing. Only when it is attached to an entity does it take affect.\n","excerpt":"Intro When you sign up for AWS using your email and password, you're assigned a user called the  user. This user has unrestricted access to…","fields":{"slug":"/IAM/"},"frontmatter":{"date":"Feb 15, 2023","title":"IAM","tags":["IAM","AWS"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Intro\n\nTypescript is a strict syntactical superset of JavaScript and adds optional static typing to the language. It is designed for the development of large applications and transpiles to JavaScript.\n\n## Compiler\n\nLet's start at the compiler: programs are files that contain a bunch of text written by you, the programmer. That text is parsed by a special program called a compiler, which trans‐ forms it into an abstract syntax tree (AST), a data structure that ignores things like whitespace, comments, and where you stand on the tabs versus spaces debate. After the TypeScript Compiler generates an AST for your program—but before it emits code—it typechecks your code. The compiler then converts that AST to a lower-level representation called bytecode. You can feed that bytecode into another program called a runtime to evaluate it and get a result. So when you run a program, what you’re really doing is telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code.\n\nWhere TypeScript is special is that instead of compiling straight to bytecode, TS compiles to JavaScript code. You then run that JavaScript code like you normally would—in your browser, or with NodeJS.\n\nThis typechecking is the magic behind TypeScript. It’s how TypeScript makes sure that your program works as you expect, that there aren’t obvious mistakes.\n\n## The Type System\n\nTo explicitly signal to TypeScript what your types are, use annotations. Annotations take the form value: type and tell the typechecker, “Hey! You see this value here? Its type is type.” Let’s look at a few examples (the comments following each line are the actual types inferred by TypeScript):\n\n```tsx\nlet a: number = 1; // a is a number\nlet b: string = 'hello'; // b is a string\nlet c: boolean[] = [true, false]; // c is an array of booleans\n```\n\nAnd if you want TypeScript to infer your types for you, just leave them off and let TypeScript get to work:\n\n```tsx\nlet a = 1; // a is a number\nlet b = 'hello'; // b is a string\nlet c = [true, false]; // c is an array of booleans\n```\n\nTypeScript is a gradually typed language. That means that TypeScript works best when it knows the types of everything in your program at compile time, but it doesn’t have to know every type in order to compile your program. Even in an untyped program, TypeScript can infer some types for you and catch some mistakes, but without knowing the types for everything, it will let a lot of mistakes slip through to your users. TypeScript statically analyzes your code for errors, and shows them to you before you run it.\n\n## tsconfig.json\n\nEvery TypeScript project should include a file called `tsconfig.json` in its root directory. This tsconfig.json is where TypeScript projects define things like which files should be compiled, which directory to compile them to, and which version of JavaScript to emit.\n\n```ts\n{\n  \"compilerOptions\": {\n    //Which APIs should TSC assume exist in the environment you’ll be running your code in? This includes things like ES5’sFunction.prototype.bind, ES2015’sObject.assign, and the DOM’s document.querySelector.\n    \"lib\": [\"es2015\"],\n    // Which module system should TSC compile your code to (CommonJS, SystemJS, ES2015, etc.)?\n    \"module\": \"commonjs\",\n    // Which folder should TSC put your generated JavaScript code in?\n    \"outDir\": \"dist\",\n    \"sourceMap\": true,\n    //Be as strict as possible when checking for invalid code. This option enforces that all of your code is properly typed. We’ll be using it for all of the examples in the book, and you should use it for your TypeScript project too.\n    \"strict\": true,\n    //Which JavaScript version should TSC compile your code to (ES3, ES5, ES2015, ES2016, etc.)?\n    \"target\": \"es2015\"\n  },\n  //# Which folders should TSC look in to find your TypeScript files?\n  \"include\": [\"src\"]\n}\n```\n\n## tslint.json\n\nYour project should also have a `tslint.json` file containing your TSLint configuration, codifying whatever stylistic conventions you want for your code (tabs versus spaces, etc.).\n\nThe following command will generate a tslint.json file with a default TSLint configuration:\n\n```bash\n./node_modules/.bin/tslint --init\n```\n\nYou can then add overrides to this to conform with your own coding style. For example, my tslint.json looks like this:\n\n```tsx\n{\n  \"defaultSeverity\": \"error\",\n  \"extends\": [\n      \"tslint:recommended\"\n  ],\n  \"rules\": {\n    \"semicolon\": false,\n    \"trailing-comma\": false\n  }\n}\n```\n\n## index.ts\n\nNow that you’ve set up your tsconfig.json and tslint.json, create a src folder containing your first TypeScript file:\n\n```bash\nmkdir src\ntouch src/index.ts\n```\n\nYour project’s folder structure should now look this:\n\n```text\n    chapter-2/\n    ├──node_modules/\n    ├──src/\n    │ └──index.ts\n    ├──package.json\n    ├──tsconfig.json\n    └──tslint.json\n```\n\nPop open src/index.ts in your code editor, and enter the following TypeScript code:\n\n```tsx\nconsole.log('Hello TypeScript!');\n```\n\nThen, compile and run your TypeScript code:\n\n```tsx\n# Compile your TypeScript with TSC\n./node_modules/.bin/tsc\n# Run your code with NodeJS\nnode ./dist/index.js\n```\n\nThis will print `Hello Typescript` in your terminal! With `ts-node` installed, you can simply do this:\n\n```bash\nts-node index.ts\n```\n\n## Types\n\nOfficially a type is set of values and the things you can do with them. For example:\n\n• The boolean type is the set of all booleans (there are just two: true and false)\nand the operations you can perform on them (like ||, &&, and !).\n\n• The number type is the set of all numbers and the operations you can perform on them (like +, -, \\*, /, %, ||, &&, and ?), including the methods you can call on them like .toFixed, .toPrecision, .toString, and so on.\n\n• The string type is the set of all strings and the operations you can perform on them (like +, ||, and &&), including the methods you can call on them like .concat and .toUpperCase.\n\nWhen you see that something is of type T, not only do you know that it’s a T, but you also know exactly what you can do with that T (and what you can’t). Remember, the whole point is to use the typechecker to stop you from doing invalid things. And the way the typechecker knows what’s valid and what’s not is by looking at the types you’re using and how you’re using them.\n\nYou can also define your own type:\n\n```tsx\ntype Programmer = {\n  /**\n   * The full name of the Programmer\n   */\n  name: string;\n  /**\n   * This Programmer is known for what?\n   */\n  knownFor: string[];\n};\n\nconst ada: Programmer = {\n  name: 'Ada Lovelace',\n  knownFor: ['Mathematics', 'Computing', 'First Programmer'],\n};\n```\n\nComments you see above are docstring comments.\n\nHere's what typescript's type hierarchy looks like:\n\n![](type-hierarchy.png)\n\nSay you have a function that takes some value and returns that value multiplied by itself:\n\n```tsx\nfunction squareOf(n) {\n  return n * n;\n}\n// squareOf(2) evaluates to 4\n// squareOf('z') evaluates to NaN\n```\n\nClearly, this function will only work for numbers—if you pass anything besides a number to squareOf, the result will be invalid. So what we do is explicitly annotate the parameter’s type:\n\n```tsx\nfunction squareOf(n: number) {\n  return n * n;\n}\n```\n\nWe can say the following things about the last code example:\n\n1. squareOf’s parameter n is constrained to number.\n\n2. The type of the value 2 is assignable to (equivalently: compatible with) number.\n\nWithout a type annotation, squareOf is unconstrained in its parameter, and you can pass any type of argument to it. Once we constrain it, TypeScript goes to work for us verifying that every place we call our function, we call it with a compatible argument.\n\n### any\n\nany is the Godfather of types. It does anything for a price, but you don’t want to ask any for a favor unless you’re completely out of options. In TypeScript everything needs to have a type at compile time, and any is the default type when you (the pro‐ grammer) and TypeScript (the typechecker) can’t figure out what type something is. It’s a last resort type, and you should avoid it when possible. any is the set of all values, and you can do anything with any. That means that if you have a value of type any you can add to it, multiply by it, call .pizza() on it—anything.\n\n```tsx\nlet a: any = 666; // any\nlet b: any = ['danger']; // any\nlet c = a + b; // any\n```\n\nUsing any in the above, no errors are thrown! My compiler returned this:\n\n```tsx\n666danger\n```\n\n### unknown\n\nFor the few cases where you have a value whose type you really don’t know ahead of time, don’t use any, and instead reach for unknown. Like any, it represents any value, but TypeScript won’t let you use an unknown type until you refine it by checking what it is. (more on refinement later)\n\n### boolean\n\n```tsx\nleta = true;\nvar b = false;\nconst c = true;\nlet d: boolean = true;\nlet e: true = true;\nlet f: true = false; // Error TS2322: Type 'false' is not assignable to type 'true'.\n```\n\n`e` isn’t just any old boolean—it’s the specific boolean true. By using a value as a type, we essentially limited the possible values for `e` and `f` from all booleans to one specific boolean each. This feature is called **type literals**.\n\n**type literal** : A type that represents a single value and nothing else\n\n### number\n\nnumber is the set of all numbers: integers, floats, positives, negatives, Infinity, NaN, and so on. Numbers can do, well, numbery things, like addition (+), subtraction (-), modulo (%), and comparison (<).Example:\n\n```tsx\nlet a = 1234;\nvar b = Infinity * 0.1;\nconst c = 5678;\nlet d = a < b; //bool\nlet e: number = 100;\nlet f: 26.218 = 26.218; // 26.218\nf = 27; // Type '27' is not assignable to type '26.218'\nlet g: 26.218 = 10; // Error TS2322: Type '10' is not assignable to type '26.218'.\n```\n\n### objects\n\nTypeScript’s object types specify the shapes of objects. If you try this:\n\n```tsx\nlet a: object = { b: 'x' };\n```\n\nyou'll get an error saying: `Property 'b' does not exist on type 'object'`. Wait, that’s not very useful! What’s the point of typing something as an object if you can’t do anything with it? `object` is a little narrower than any, but not by much. object doesn’t tell you a lot about the value it describes, just that the value is a JavaScript object (and that it’s not null).\n\nYou can do 2 things:\n\n- Leave off the `object`:\n\n```tsx\nlet a = { b: 'x' };\n```\n\n- Explicitly provide type for `b`:\n\n```tsx\nlet a: { b: string } = {\n  b: 'hello!',\n};\nconsole.log(a.b);\n```\n\nThis is called `object literal` syntax. Object literal syntax says, “Here is a thing that has this shape.” The thing might be an object literal, or it might be a class:\n\n```tsx\nlet a: { firstName: string; lastName: string } = {\n  firstName: 'john',\n  lastName: 'barrowman',\n};\nclass Person {\n  constructor(public firstName: string, public lastName: string) {}\n}\na = new Person('matt', 'smith'); // OK\n```\n\n`{firstName: string, lastName: string}` describes the shape of an object, and both the object literal and the class instance from the last example satisfy that shape, so TypeScript lets us assign a Person to `a`.\n\nCan you tell TypeScript that something is optional, or that there might be more properties than you planned for? You bet:\n\n```tsx\nlet a: {\n  b: number; // 1\n  c?: string; // 2\n  [key: number]: boolean; // 3\n};\n```\n\n`a`:\n\n1. has property `b` that is a number\n\n2. might have a property `c` that is string that is optional. And if `c` exists, it might be undefined\n\n3. might have any number of numeric properties that are booleans. This too is optional\n\nExample:\n\n```tsx\na = { b: 1, c: undefined, 10: true, 20: false, 30: true };\na = { b: 1, c: undefined };\na = { b: 1, c: 'd' };\na = { b: 1, 10: true };\na = { b: 1, 10: true, 20: false };\n```\n\nThe `[key: T]: U` `([key: number]: boolean)` syntax is called an **index signature**, and this is the way you tell TypeScript that the given object might contain more keys. The way to read it is, “For this object, all keys of type T (`number` in our example) must have values of type U (`boolean` in our example).” Index signatures let you safely add more keys to an object, in addition to any keys that you explicitly declared. What this means is that for `a`, if you have a number on the left, then it must have a boolean assigned:\n\n```tsx\n// not ok:\nlet a: {\n  b: number;\n  c?: string;\n  2: string; // <-- NO!\n  [key: number]: boolean;\n};\n```\n\nError for above will be: `Property '2' of type 'string' is not assignable to 'number' index type 'boolean'.ts(2411)`\n\n```tsx\n// this is ok:\nlet a: {\n  b: number;\n  c?: string;\n  2: boolean;\n  5: boolean;\n  [key: number]: boolean;\n};\n\na = { b: 1, c: undefined, 10: true, 20: false, 2: true, 5: false };\n```\n\nThere is one rule to keep in mind for index signatures: the index signature key’s type, T, must be assignable to either number or string. More on index signatures [here](https://basarat.gitbook.io/typescript/type-system/index-signatures).\n\nLet's look at another index signature example: say you want to make sure that anything that is stored in an object using a string conforms to the structure `{message: string}`. This can be done with the declaration `{ [index:string] : {message: string} }`. This is demonstrated below:\n\n```tsx\nlet foo: { [index: string]: { message: string } } = {};\n\n/**\n * Must store stuff that conforms to the structure\n */\n/** Ok */\nfoo['a'] = { message: 'some message' };\n/** Error: must contain a `message` of type string. You have a typo in `message` */\nfoo['a'] = { messages: 'some message' };\n\n/**\n * Stuff that is read is also type checked\n */\n/** Ok */\nfoo['a'].message;\n/** Error: messages does not exist. You have a typo in `message` */\nfoo['a'].messages;\n```\n\nAlso note that you can use any word for the index signature key’s name—it doesn’t have to be key:\n\n```tsx\nlet airplaneSeatingAssignments: { [seatNumber: string]: string } = {\n  '34D': 'Boris Cherny',\n  '34E': 'Bill Gates',\n};\n```\n\nYou can also have lists as type. Say for example, I have an object representing different age groups:\n\n```tsx\nlet ageGroups: {\n  [groupName: string]: number[];\n} = {};\n\nageGroups['under18s'] = [17, 16, 15, 14, 13];\n```\n\nWhat you see above is an object literal notation special case: empty object types: `{}`. Every type except null and undefined is assignable to an empty object type, which can make it tricky to use. Try to avoid empty object types when possible! A better way to redo the prev example would be:\n\n```tsx\nlet ageGroups: {\n  [groupName: string]: number[];\n} = { under18s: [17, 16, 15, 14, 13] };\n```\n\nOther examples to avoid:\n\n```tsx\nlet danger: {};\ndanger = {};\ndanger = { x: 1 };\ndanger = [];\ndanger = 2;\n```\n\nTo summarize, here are the ways to declare objects in TypeScript:\n\n1. They can be anonymous:.\n\n```tsx\ngreet({ name: 'you', age: 12 });\nfunction greet(person: { name: string; age: number }) {\n  return 'Hello ' + person.name;\n}\n```\n\n2. They can be named by using either an interface:\n\n```tsx\ninterface Person {\n  name: string;\n  age: number;\n}\n\nconst me: Person = {\n  name: 'you',\n  age: 12,\n};\n\ngreet(me);\n\nfunction greet(person: Person) {\n  console.log('Hello ' + person.name + \"'re: \" + person.age);\n}\n```\n\n3. or a type alias:\n\n```tsx\ntype Person = {\n  name: string;\n  age: number;\n};\n\nfunction greet(person: Person) {\n  return 'Hello ' + person.name;\n}\n```\n\n### type aliases\n\nIt’s common to want to use the same type more than once and refer to it by a single name. To do so, we can create an \"alias\": - a name for any type. The syntax for a type alias is:\n\n```tsx\ntype Point = {\n  x: number;\n  y: number;\n};\n\nfunction printCoord(pt: Point) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n\nType aliases are useful for DRYing up repeated complex types,5 and for making it clear what a variable is used for.\n\n### union and intersection types\n\nIf you have two things A and B, the union of those things is their sum (everything in A or B or both), and the intersection is what they have in common (everything in both A and B). TypeScript gives us special type operators to describe unions and intersections of types: `|` for union and `&` for intersection. Since types are a lot like sets, we can think of them in the same way. Let's look at an example:\n\n```tsx\ntype Cat = { name: string; purrs: boolean; social: boolean };\ntype Dog = { name: string; wags: boolean; barks: boolean };\ntype CatAndDog = Cat & Dog;\ntype CatOrDogOrBoth = Cat | Dog;\n```\n\nIf something is a CatOrDogOrBoth, what do you know about it? You know that it has a name property that’s a string, and not much else. On the flip side, what can you assign to a CatOrDogOrBoth? Well, a Cat, a Dog, or both:\n\n```tsx\nconst fourLeggedCat: CatOrDogOrBoth = {\n  name: 'cat',\n  purrs: true,\n  social: false,\n};\n\nconst fourLeggedDog: CatOrDogOrBoth = {\n  name: 'dog',\n  wags: true,\n  barks: true,\n};\n\nconst fourLeggedBoth: CatOrDogOrBoth = {\n  name: 'catdog',\n  wags: true,\n  barks: true,\n  purrs: true,\n  social: false,\n};\n```\n\nThis is worth reiterating: a value with a union type `|` isn’t necessarily one specific member of your union; in fact, it can be both members at once!\n\nOn the other hand, what do you know about CatAndDog? Not only does your canine, feline hybrid super-pet have a name, but it can purr, bark, and wag:\n\n```tsx\nconst kittyRocky: CatAndDog = {\n  name: 'kittyRocky',\n  purrs: true,\n  social: false,\n  wags: true,\n  barks: true,\n};\n```\n\n### arrays\n\nLike in JavaScript, TypeScript arrays are special kinds of objects that support things like concatenation, pushing, searching, and slicing. TypeScript supports two syntaxes for arrays: `T[]` and `Array<T>`. They are identical both in meaning and in performance.\n\n```tsx\nlet a = [1, 2, 3]; // number[]\nvar b = ['a', 'b']; // string\nlet c: string[] = ['a']; //string\nlet d = [1, 'a']; // (number | string)[]\nconst e = [2, 'b']; // (number | string)[]\nlet f = ['red'];\nf.push('blue');\n// Error TS2345: Argument of type 'true' is not\n// assignable to parameter of type 'string':\nf.push(true);\n```\n\nWe initialized `f` with the string 'red'. We then pushed 'blue' onto it; 'blue' is a string, so TypeScript let it pass. Then we tried to push true onto the array, but that failed! Why? Because `f` is an array of strings, and true is not a string.\n\nOn the other hand, when we initialized `d`, we gave it a number and a string, so TypeScript inferred that it must be an array of type number `|` string. Because each element might be either a number or a string, you have to check which it is before using it. Like with objects, creating arrays with const won’t hint to TypeScript to infer their types more narrowly. That’s why TypeScript inferred both d and e to be arrays of number | string.\n\n`g` below is the special case: when you initialize an empty array, TypeScript doesn’t know what type the array’s elements should be, so it gives you the benefit of the doubt and makes them any. As you manipulate the array and add elements to it, TypeScript starts to piece together your array’s type. Once your array leaves the scope it was defined in (for example, if you declared it in a function, then returned it), TypeScript will assign it a final type that can’t be expanded anymore:\n\n```tsx\nlet g = []; // any[]\ng.push(1); // number[]\ng.push('red'); // string []\n```\n\n### tuples\n\nTuples are subtypes of array. They’re a special way to type arrays that have fixed lengths, where the values at each index have specific, known types. Unlike most other types, tuples have to be explicitly typed when you declare them. That’s because the JavaScript syntax is the same for tuples and arrays (both use square brackets), and TypeScript already has rules for inferring array types from square brackets:\n\n```tsx\nlet a: [number] = [1];\n// A tuple of [first name, last name, birth year]\nlet b: [string, string, number] = ['malcolm', 'gladwell', 1963];\n\n// Error TS2322: Type 'string' is not assignable to type 'number':\nb = ['queen', 'elizabeth', 'ii', 1926];\n```\n\nTuples also support rest elements, which you can use to type tuples with minimum lengths:\n\n```tsx\n// A list of strings with at least 1 element\nlet friends: [string, ...string[]] = ['Sara', 'Tali', 'Chloe', 'Claire'];\n\n// A heterogeneous list\nlet list: [number, boolean, ...string[]] = [1, false, 'a', 'b', 'c'];\n```\n\n### null, undefined, void, and never\n\nJavaScript has two values to represent an absence of something: `null` and `undefined`. TypeScript supports both of these as values, and it also has types for them: `null` and `undefined`. They’re both special types, because in TypeScript the only thing of type undefined is the value `undefined`, and the only thing of type null is the value `null`.\n\n`undefined` means that something hasn’t been defined yet.\n\n`null` means an absence of a value (like if you tried to compute a value, but ran into an error along the way).\n\nIn addition to `null` and `undefined`, TypeScript also has `void` and `never`. These are really specific, special-purpose types that draw even finer lines between the different kinds of things that don’t exist:\n\n- `void` is the return type of a function that doesn’t explicitly return anything (for example, console.log)\n- `never` is the type of a function that never returns at all (like a function that throws an exception, or one that runs forever)\n\n### enums\n\nEnums are a way to enumerate the possible values for a type. They are unordered data structures that map keys to values. Think of them like objects where the keys are fixed at compile time, so TypeScript can check that the given key actually exists when you access it.\n\nBy convention, enum names are uppercase and singular. Their keys are also uppercase.\n\n```tsx\nenum Frequency {\n  Monthly,\n  Daily,\n  Weekly,\n}\nconsole.log(frequency.MONTHLY);\n```\n\nTypeScript will automatically infer a number as the value for each member of your enum, but you can also set values explicitly. Let’s make explicit what TypeScript inferred in the previous example:\n\n```tsx\nenum Frequency {\n  Monthly = 0,\n  Daily = 1,\n  Weekly = 2,\n}\n```\n\nTo retrieve a value from an enum, you access it with either dot or bracket notation— just like you would to get a value from a regular object:\n\n```tsx\nlet monthly = Frequency.Monthly;\nlet daily = Frequency['Daily'];\n```\n\nYou can also use string values for enums, or even mix string and number values:\n\n```tsx\nenum Color {\n  Red = '#c10000',\n  Blue = '#007ac1',\n  Pink = 0xc10050, // A hexadecimal literal\n  White = 255, // decimal literal\n}\n```\n\n```tsx\nlet a = Color.Red;\n// Error TS2339: Property 'Green' does not exist\n// on type 'typeof Color'.\nlet b = Color.Green;\n// string\nlet c = Color[0];\n// string (!!!) <--- UNSAFE!!\nlet d = Color[6];\n```\n\nUse `const` so that it's safer:\n\n```tsx\nconst enum Color {\n  Red = '#c10000',\n  Blue = '#007ac1',\n  Pink = 0xc10050, // A hexadecimal literal\n  White = 255, // decimal literal\n}\n```\n\nAccessing a valid enum would now require a string literal:\n\n```tsx\n// Error TS2476: A const enum member can only be\n// accessed using a string literal.\nColor[0];\nColor.Red;\n```\n\n### record types\n\nThe `Record<Keys, Type>` type is a type that can ensure consistency in implementing a dictionary (key-value pairs) with fixed values/type for Keys and a defined type for the values. Record types keys have to be unique.\n\n```tsx\ninterface CatInfo {\n  age: number;\n  breed: string;\n}\n\ntype CatName = 'miffy' | 'boris' | 'mordred';\n\nconst cats: Record<CatName, CatInfo> = {\n  miffy: { age: 10, breed: 'Persian' },\n  boris: { age: 5, breed: 'Maine Coon' },\n  mordred: { age: 16, breed: 'British Shorthair' },\n};\n\nconsole.log(cats.boris.age);\n```\n\nIn short, TypeScript comes with a bunch of built-in types. You can let TypeScript infer types for you from your values, or you can explicitly type your values. const will infer more specific types, let and var more general ones.\n\n## functions\n\nIn JavaScript, functions are first-class objects. That means you can use them exactly like you would any other object: assign them to variables, pass them to other func‐ tions, return them from functions, assign them to objects and prototypes, write prop‐ erties to them, read those properties back, and so on. There is a lot you can do with functions in JavaScript, and TypeScript models all of those things with its rich type system.\n\nHere’s what a function looks like in TypeScript:\n\n```tsx\nfunction doubleIt(x: number) {\n  return 2 * x;\n}\n```\n\nYou will usually explicitly annotate function parameters (a and b in this example)— TypeScript will always infer types throughout the body of your function, but in most cases it won’t infer types for your parameters, except for a few special cases where it can infer types from context (contextual typing later). The return type is inferred, but you can explicitly annotate it too if you want:\n\n```tsx\nfunction doubleIt(x: number): number {\n  return 2 * x;\n}\n```\n\nThe last example used named function syntax to declare the function. TypeScript supports the following ways to do this:\n\n1. Named function\n\n```tsx\nfunction greet(name: string) {\n  return 'hello ' + name;\n}\n```\n\n2. Function Expression\n\n```tsx\nlet greet2 = function (name: string) {\n  return 'hello ' + name;\n};\n```\n\n3. Arrow Function Expression\n\n```tsx\nlet greet3 = (name: string) => {\n  return 'hello ' + name;\n};\n```\n\n4. Shorthand Arrow function expression\n\n```tsx\nlet greet4 = (name: string) => 'hello ' + name;\n```\n\n### optional and default parameters\n\nLike in object and tuple types, you can use `?` to mark parameters as optional. When declaring your function’s parameters, required parameters have to come first, followed by optional parameters:\n\n```tsx\nfunction log(message: string, userId?: string) {\n  let time = new Date().toLocaleTimeString();\n  console.log(time, message, userId || 'Not signed in');\n}\n```\n\nYou can provide default values for optional parameters. Semantically it’s similar to making a parameter optional, in that callers no longer have to pass it in (a difference is that default parameters don’t have to be at the end of your list of parameters, while optional parameters do):\n\n```tsx\nfunction withOptional(id: number, name = 'default name', age?: number) {\n  console.log('id: ' + id + ' name: ' + name + ' age: ' + (age ? age : 21));\n}\n\n// id: 123 name: Provided Name age: 18\nwithOptional(123, 'Provided Name', 18);\n// id: 123 name: Provided Name age: 21\nwithOptional(123, 'Provided Name');\n// id: 123 name: default name age: 21\nwithOptional(123);\n```\n\nNotice how when we give name a default value, we remove its optional annotation, `?`. We also don’t have to type it anymore. TypeScript is smart enough to infer the parameter’s type from its default value, keeping our code terse and easy to read.\n\nOrder is: required params > ones with default params > optional params\n\n### rest parameters\n\nSometimes, you might opt for a variadic function API—one that takes a variable number of arguments—instead of a fixedarity API that takes a fixed number of arguments. For variadic functions, you use rest parameters:\n\n```tsx\nshowRest(1, 2, 3, 4, 5);\n\nfunction showRest(...scores: number[]) {\n  let total = 0;\n  scores.forEach((score) => {\n    total += score;\n  });\n  console.log('final score is: ', total);\n}\n```\n\nNotice how we're not passing in an array BUT a variable number (no pun intended!) of numbers! `scores` is NOT of type array of numbers but is a rest parameter that accepts an unfixed number of numbers.\n\nA function can have at most one rest parameter, and that parameter has to be the last one in the function’s parameter list.\n\n### call signatures\n\nLet's talk about how we can express the full types of functions. Let’s look at a `sum` function:\n\n```tsx\nfunction sum(a: number, b: number): number {\n  return a + b;\n}\n```\n\nWhat is the type of `sum`? Well, sum is a function, so its type is: `Function`\n\nThe Function type is not what you want to use most of the time. Like `object` describes all objects, `Function` is a catchall type for all functions, and doesn’t tell you anything about the specific function that it types.\n\nHow else can we type sum? sum is a function that takes two numbers and returns a number. In TypeScript we can express its type as:\n\n```tsx\n// function sum(a: number, b: number): number {\n//   return a + b;\n// }\n(a: number, b: number) => number;\n```\n\nThis is TypeScript’s syntax for a function’s type, or call signature (also called a type signature). You’ll notice it looks remarkably similar to an arrow function—this is intentional! When you pass functions around as arguments, or return them from other functions, this is the syntax you’ll use to type them. The parameter names a and b just serve as documentation, and don’t affect the assignability of a function with that type.\n\nFunction call signatures only contain type level code: that is, types only, no values.\n\nLet’s go through a few of the examples of functions and pull out their types into standalone call signatures that we’ll bind to type aliases:\n\n```tsx\n// function greet(name: string)\ntype Greet = (name: string) => string;\n\n// function log(message: string, userId?: string)\ntype Log = (message: string, userId?: string) => void;\n\n// function sumVariadicSafe(...numbers: number[]): number\ntype SumVariadicSafe = (...numbers: number[]) => number;\n```\n\nThe functions’ call signatures (type level code) look remarkably similar to their implementations. This is intentional, and is a language design choice that makes call signatures easier to reason about.\n\nLet’s make the relationship between call signatures and their implementations more concrete. If you have a call signature, how can you declare a function that implements that signature? You simply combine the call signature with a function expression that implements it.\n\nUsing the type `Log` from earlier, here's what we can do:\n\n```tsx\ntype Log = (message: string, userId?: string) => void;\n\nlet log: Log(\n  message,\n  userId =  'defaultUserId'\n) => {\n  let time = new Date().toISOString()\n  console.log(time, message, userId)\n}\n```\n\n1.  We declare a function expression `log`, and explicitly type it as type `Log`.\n\n2.  We don’t need to annotate our parameters twice. Since message is already annotated as a string as part of the definition for `Log`, we don’t need to type it again here. Instead, we let TypeScript infer it for us from `Log`.\n\n3.  We add a default value for `userId`, since we captured userId’s type in our signature for `Log`, but we couldn’t capture the default value as part of `Log` because `Log` is a type and can’t contain values.\n\n4.  We don’t need to annotate our return type again, since we already declared it as void in our Log type.\n\nLet's look at another example using the type `SumVariadicSafe` from earlier. Here's what we can do:\n\n```tsx\ntype SumVariadicSafe = (...scores: number[]) => number;\n\nlet sumIt: SumVariadicSafe = (...scores) => {\n  let total = 0;\n  scores.forEach((score) => {\n    total += score;\n  });\n  return total;\n};\n```\n\n1. We declare a function expression `sumIt`, and explicitly type it as type `SumVariadicSafe`.\n2. We don’t need to annotate our parameters twice. Since scores is already annotated as a rest parameter as part of the definition for `SumVariadicSafe`, we don’t need to type it again here. Instead, we let TypeScript infer it for us from `SumVariadicSafe`.\n\n### contextual typing\n\nBecause we already declared that log is of type `Log`, TypeScript is able to infer from context that message has to be of type string. This is a powerful feature of TypeScript’s type inference called contextual typing.\nLet’s declare a function `times` that calls its callback `f` some number of times `n`, passing the current index to `f` each time: (“callback” is a function that you passed as an argument to another function.)\n\n```py\nfunction times(\n  f: (index: number) => void,\n  n: number\n) {\n    for (let i = 0; i < n; i++) {\n      f(i);\n    }\n}\n```\n\nWhen you call times, you don’t have to explicitly annotate the function you pass to times if you declare that function inline:\n\n```tsx\ntimes((n) => console.log(n), 4);\n```\n\n### overloaded functions\n\nWhat we saw earlier is also called shorthand signature. There's also a full call signature that does exactly the same thing:\n\n```tsx\n// Shorthand call signature\ntype Log = (message: string, userId?: string) => void;\n\n// Full call signature\ntype Log = {\n  (message: string, userId?: string): void;\n};\n```\n\nFor simple cases like our `Log` function, you should prefer the shorthand; but for more complicated functions, there are a few good use cases for full signatures. The first of these is overloading a function type: **overloaded function** is a function with multiple call signatures. You can use overloaded function signatures to design really expressive APIs. For example, let’s design an API to book a vacation—we’ll call it Reserve. Let’s start by sketching out its types (with a full type signature this time):\n\n```tsx\ntype Reserve = {\n  (from: Date, to: Date, destination: string): Reservation;\n};\n```\n\nLet’s then stub out an implementation for Reserve:\n\n```tsx\nlet reserve: Reserve = (from, to, destination) => {\n  // ...\n};\n```\n\nSo a user who wants to book a trip to Bali has to call our reserve API with a from date, a to date, and \"Bali\" as a destination. We might repurpose our API to support one-way trips too:\n\n```tsx\ntype Reservation = {\n  from: Date;\n  to?: Date;\n  destination: String;\n  message: String;\n};\n\ntype Reserve = {\n  // Signature1\n  (from: Date, to: Date, destination: string): Reservation;\n  // Signature2\n  (from: Date, destination: string): Reservation;\n};\n\nlet oneWayToBali: Reserve = (from, to, destination) => {\n  return {\n    from: from,\n    to: to,\n    destination: destination,\n    message: 'Thank you for flying to ' + to + ' from ' + from + ' with us!',\n  };\n};\n```\n\nFor the above, `oneWayToBali` will return an error saying:\n\n```tsx\nType '(from: Date, to: Date, destination: string) => { from: Date; to: Date; destination: string; message: string; }'\nis not assignable to type 'Reserve'.ts(2322)\n```\n\nThis is because of the way call signature overloading works in TypeScript. If you declare a set of overload signatures for a function `f`, from a caller’s point of view `f`’s type is the union of those overload signatures. But from `f`’s implementation’s point of view, there needs to be a single, combined type that can actually be implemented. You need to manually declare this combined call signature when implementing `f`, it won’t be inferred for you. For our Reserve example, we can update our reserve function like this:\n\n```tsx\n// From:\ntype Reserve = {\n  (from: Date, to: Date, destination: string): Reservation;\n  (from: Date, destination: string): Reservation;\n};\n// To:\ntype Reserve = {\n  (from: Date, toOrDestination: Date, destination?: string): Reservation;\n};\n```\n\nThe implementation’s new signature is the result of us manually combining the two overload signatures (in other words, we computed `Signature1` | `Signature2` by hand). Note that the combined signature isn’t visible to functions that call reserve; from a consumer’s point of view, Reserve’s signature is:\n\n```tsx\ntype Reserve = {\n  (from: Date, to: Date, destination: string): Reservation;\n  (from: Date, destination: string): Reservation;\n};\n```\n\nHere's a full example making use of the overloaded function. We have a one way trip to Bali and a round trip to Mexico:\n\n```tsx\n// Returned from Reserve\ntype Reservation = {\n  from: Date;\n  toOrDestination?: Date | String;\n  message: String;\n};\n\n// Type to Reserve\ntype Reserve = {\n  (from: Date, toOrDestination: Date | string, destination?: string): Reservation;\n};\n\n// Just some dates for testing\nconst today = new Date();\nconst to = new Date(today);\nto.setDate(to.getDate() + 3);\n```\n\nHere's the main function. If you want a one way trip, pass in a string to `toOrDestination` and leave optional param `destination` undefined. If you want a round trip, provide to date for `toOrDestination` and ALSO provide `destination` param.\n\n```tsx\n/**\n * Function to make a reservation\n * @param from Date you want to leave\n * @param toOrDestination Could be date (to) for round trip or destination for 1 way\n * @param destination Optional param only to be defined if it is a round trip.\n * @returns Type Reservation\n */\nlet makeReservation: Reserve = (from, toOrDestination, destination): Reservation => {\n  let message = 'Thanks for flying ';\n  typeof toOrDestination == 'string'\n    ? (message = message + 'one way to ' + toOrDestination + '. You leave: ' + from.toString())\n    : (message =\n        message +\n        'round trip ' +\n        destination +\n        '. You leave: ' +\n        from.toString() +\n        ' and return ' +\n        toOrDestination.toString());\n  return {\n    from: from,\n    toOrDestination: toOrDestination,\n    message: message,\n  };\n};\n\nconsole.log(makeReservation(today, 'Bali').message);\nconsole.log('**********');\nconsole.log(makeReservation(today, to, 'Bali').message);\n```\n\nSince `makeReservation` might be called in either of two ways, when you implement `makeReservation` you have to prove to TypeScript that you checked how it was called (what I did with checking `toOrDestination`).\n\n### polymorphism\n\nSo far, we've looked at concrete types: boolean, string, number etc. Concrete types are useful when you know precisely what type you’re expecting, and want to verify that type was actually passed. But sometimes, you don’t know what type to expect beforehand, and you don’t want to restrict your function’s behavior to a specific type!\n\nAs an example, let’s implement filter. You use filter to iterate over an array and refine it; in JavaScript, it might look like this:\n\n```js\nfunction filter(array, f) {\n  let result = []\n  for (let i = 0; i < array.length; i++) {\n    let item = array[i] if (f(item)) {\n      result.push(item)\n    }\n  }\n  return result\n}\n\nfilter([1, 2, 3, 4], _ => _ < 3) // evaluates to [1, 2]\n```\n\nLet’s start by pulling out filter’s full type signature, and adding some placeholder unknowns for the types:\n\n```tsx\ntype Filter = {\n  (array: unknown, f: unknown) => unknown[]\n}\n```\n\nNow, let’s try to fill in the types with, say, number:\n\n```tsx\ntype Filter = {\n  (array: number[], f: (item: number) => boolean): number[];\n};\n```\n\nTyping the array’s elements as number works well for this example, but filter is meant to be a generic function—you can filter arrays of numbers, strings, objects, other arrays, anything. The signature we wrote works for arrays of numbers, but it doesn’t work for arrays of other types of elements.\n\nTo make filter more useful, we'll use **generic types parameters**: It is nothing but a placeholder type used to enforce a type-level constraint in multiple places. Also known as polymorphic type parameter.\n\nGoing back to our filter example, here is what its type looks like when we rewrite it with a generic type parameter T:\n\n```tsx\n// Earlier:\ntype Filter = {\n  (array: unknown, f: unknown) => unknown[]\n}\n\n//Generic:\ntype Filter = {\n  <T>(array: T[], f: (item: T) => boolean): T[];\n};\n```\n\nWhat this means is that our type `Filter` will accept an array of type `T`, an `f` function that accepts item of type `T` that returns a boolean and finally our `Filter` will return an array of `T`s.\n\nThis function filter uses a generic type parameter T; we don’t know what this type will be ahead of time, so we let TypeScript infer what it is each time we call filter. TypeScript infers T from the type we pass in for array. Once TypeScript infers what T is for a given call to filter, it substitutes that type in for every T it sees. T is like a placeholder type, to be filled in by the typechecker from context; it parameterizes Filter’s type, which is why we call it a generic type parameter.\n\nBecause it’s such a mouthful to say “generic type parameter” every time, people often shorten it to just “generic type,” or simply “generic.”\n\nThe angle brackets, `<>`, are how you declare generic type parameters (think of them like the type keyword, but for generic types); where you place the angle brackets scopes the generics (there are just a few places you can put them), and TypeScript makes sure that within their scope, all instances of the generic type parameters are eventually bound to the same concrete types.\n","excerpt":"Intro Typescript is a strict syntactical superset of JavaScript and adds optional static typing to the language. It is designed for the dev…","fields":{"slug":"/Typescript/"},"frontmatter":{"date":"Feb 10, 2023","title":"Typescript","tags":["typescript"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}